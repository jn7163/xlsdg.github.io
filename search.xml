<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Grunt 配置]]></title>
      <url>%2F2015%2F08%2F14%2Fgrunt-configuration%2F</url>
      <content type="text"><![CDATA[Grunt 安装前提条件：电脑已经配置好 Node.js 的环境。 1$ npm install -g grunt-cli 进入工程目录，运行以下命令生成 package.json 文件: 1$ npm init 接着输入以下命令直接安装 Grunt： 1$ npm install --save-dev grunt 除了安装 Grunt 以外，不同的项目还需要安装不同的 Grunt 插件模块。常用模块： 1234567891011121314$ npm install --save-dev load-grunt-tasks$ npm install --save-dev grunt-contrib-jshint$ npm install --save-dev grunt-contrib-csslint$ npm install --save-dev grunt-htmlhint$ npm install --save-dev grunt-contrib-watch$ npm install --save-dev grunt-shell$ npm install --save-dev grunt-contrib-concat$ npm install --save-dev grunt-contrib-clean$ npm install --save-dev grunt-contrib-less$ npm install --save-dev grunt-autoprefixer$ npm install --save-dev grunt-contrib-uglify$ npm install --save-dev grunt-contrib-cssmin$ npm install --save-dev grunt-contrib-imagemin$ npm install --save-dev grunt-contrib-htmlmin 或一行命令解决： 1$ npm install --save-dev load-grunt-tasks grunt-contrib-jshint grunt-contrib-csslint grunt-htmlhint grunt-contrib-watch grunt-shell grunt-contrib-concat grunt-contrib-clean grunt-contrib-less grunt-autoprefixer grunt-contrib-uglify grunt-contrib-cssmin grunt-contrib-imagemin grunt-contrib-htmlmin 模板文件每次都要输入这么多命令，有时候会记不住。其实我们只需要一个 package.json 文件就可以搞定： 12345678910111213141516171819202122232425262728293031&#123; "name": "grunt-demo", "version": "1.0.0", "description": "just for learn grunt.", "main": "app.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "grunt" ], "author": "xLsDg", "license": "MIT", "devDependencies": &#123; "grunt": "^0.4.5", "grunt-autoprefixer": "^3.0.3", "grunt-contrib-clean": "^0.6.0", "grunt-contrib-concat": "^0.5.1", "grunt-contrib-csslint": "^0.5.0", "grunt-contrib-cssmin": "^0.13.0", "grunt-contrib-htmlmin": "^0.4.0", "grunt-contrib-imagemin": "^0.9.4", "grunt-contrib-jshint": "^0.11.2", "grunt-contrib-less": "^1.0.1", "grunt-contrib-uglify": "^0.9.1", "grunt-contrib-watch": "^0.6.1", "grunt-htmlhint": "^0.4.1", "grunt-shell": "^1.1.2", "load-grunt-tasks": "^3.2.0" &#125;&#125; 每次需要使用的时候，将该文件放到项目文件夹下，在终端中输入 npm install 即可自动安装相应的模块。 配置文件安装完模块之后，还需要配置一下对应的工作参数。新建 Gruntfile.js 文件与 package.json 文件同一个目录下，内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292module.exports = function(grunt) &#123; var cwdDir = __dirname; var cssSrc = cwdDir + '/less'; var cssDst = cwdDir + '/css'; var jsSrc = cwdDir + '/js/page'; var jsDst = cwdDir + '/js/dist'; var htmlSrc = cwdDir + '/views'; var htmlDst = cwdDir + '/html'; var imgSrc = cwdDir + '/img'; var imgDst = cwdDir + '/img/dist'; require('load-grunt-tasks')(grunt, &#123; pattern: 'grunt-*', config: cwdDir + '/package.json', scope: 'devDependencies' &#125;); grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), autoprefixer: &#123; options: &#123; browsers: [ 'ie &gt;= 8', 'ff &gt;= 10', 'chrome &gt;= 20', 'safari &gt;= 7', 'opera &gt;= 10', 'ios &gt;= 7', 'android &gt;= 2.3' ] &#125;, src: [cssDst + '/*.css'] &#125;, clean: &#123; options: &#123; 'force': false, // This overrides this task from blocking deletion of folders outside current working dir (CWD). Use with caution. 'no-write': false // Will log messages of what would happen if the task was run but doesn't actually delete the files. &#125;, css: &#123; files: [&#123; src: [cssDst + '/*.css'] &#125;] &#125;, js: &#123; files: [&#123; src: [jsDst + '/*.js'] &#125;] &#125;, html: &#123; files: [&#123; src: [htmlDst + '/*.html'] &#125;] &#125; &#125;, concat: &#123; options: &#123; separator: ';' // Concatenated files will be joined on this string. If you're post-processing concatenated JavaScript files with a minifier, you may need to use a semicolon ';\n' as the separator. &#125;, css: &#123; src: [cssDst + '/*.css', '!' + cssDst + '/all.css'], dest: cssDst + '/all.css', &#125;, js: &#123; src: [jsDst + '/*.js', '!' + jsDst + '/all.js'], dest: jsDst + '/all.js', &#125; &#125;, csslint: &#123; options: &#123; 'important': false, 'adjoining-classes': false, 'known-properties': false, 'box-sizing': false, 'box-model': false, 'overqualified-elements': false, 'display-property-grouping': true, 'bulletproof-font-face': true, 'compatible-vendor-prefixes': false, 'regex-selectors': true, 'errors': true, 'duplicate-background-images': true, 'duplicate-properties': true, 'empty-rules': true, 'selector-max-approaching': true, 'gradients': true, 'fallback-colors': true, 'font-sizes': false, 'font-faces': true, 'floats': false, 'star-property-hack': false, 'outline-none': false, 'import': true, 'ids': true, 'underscore-property-hack': false, 'rules-count': true, 'qualified-headings': false, 'selector-max': true, 'shorthand': true, 'text-indent': true, 'unique-headings': false, 'universal-selector': true, 'unqualified-attributes': false, 'vendor-prefix': false, 'zero-units': true, 'force': true &#125;, src: [cssDst + '/*.css'] &#125;, cssmin: &#123; options: &#123; compatibility : 'ie8', noAdvanced : true &#125;, target: &#123; files: [&#123; expand: true, cwd: cssDst, src: ['*.css', '!*.min.css'], dest: cssDst, ext: '.min.css' &#125;] &#125; &#125;, htmlmin: &#123; options: &#123; removeComments: true, collapseWhitespace: true &#125;, files: [&#123; expand: true, cwd: htmlDst, src: ['*.html'], dest: htmlDst &#125;] &#125;, imagemin: &#123; options: &#123; optimizationLevel: 3, svgoPlugins: [&#123; removeViewBox: false &#125;], use: [] &#125;, files: [&#123; expand: true, cwd: imgSrc, src: ['*.&#123;png,jpg,gif&#125;'], dest: imgDst &#125;] &#125;, jshint: &#123; options: &#123; 'jquery': true, //检查预定义的全局变量，防止出现$未定义，该项根据实际代码修改 'bitwise': false, //不检查位运算 'browser': true, //通过浏览器内置的全局变量检测 'devel': true, //允许对调试用的alert和console.log的调用 'camelcase': true, //强制验证驼峰式命名 'curly': true, //强制使用花括号 'eqeqeq': false, //不强制使用===比较运算符 'es3': true, //兼容es3规范，针对旧版浏览器编写的代码 'esnext': false, //不使用最新的es6规范 'expr': true, //允许未赋值的函数名表达式，例如console &amp;&amp; console.log(1) 'forin': false, //不强制过滤遍历对象继承的属性 'freeze': false, //不限制对内置对象的扩展 'immed': true, //禁止未用括号包含立即执行函数 'indent': false, //不强制缩进 'latedef': true, //禁止先调用后定义 'maxdepth': false, //不限制代码块嵌套层数 'maxparams': false, //不限制函数参数个数 'newcap': false, //不对首字母大写的函数强制使用new 'noarg': false, //不禁止对arguments.caller和arguments.callee的调用 'noempty': false, //不禁止空代码块 'nonew': false, //允许直接new实例化而不赋值给变量 'plusplus': false, //允许++和--运算符使用 'quotmark': 'single', //字符串使用单引号 'scripturl': true, //允许javascript伪协议的url 'smarttabs': false, //允许混合tab和空格缩进 'strict': false, //不强制使用es5严格模式 'sub': true, //允许用[]形式访问对象属性 'undef': true, //禁止明确未定义的变量调用，如果你的变量（myvar）是在其他文件中定义的，可以使用/*global myvar */绕过检测 'unused': false, //允许定义没用的变量，在某些函数回调中，经常出现多个参数，但不一定会用 'multistr': false, //禁止多行字符串，改用加号连接 'globals': &#123; 'jQuery': true, 'FastClick': true, 'define': true, 'unescape': true, 'require': true, 'iScroll': true, 'host': true &#125; &#125;, src: [jsDst + '/*.js'] &#125;, less: &#123; options: &#123; &#125;, files: [&#123; expand: true, cwd: cssSrc, src: ['*.less'], dest: cssDst &#125;] &#125;, uglify: &#123; options: &#123; &#125;, files: [&#123; expand: true, cwd: jsDst, src: ['*.js', '!all.js'], dest: jsDst &#125;] &#125;, watch: &#123; css: &#123; options: &#123; &#125;, files: [cssSrc + '/*.less'], tasks: ['clean:css', 'less', 'csslint', 'autoprefixer', 'cssmin'] &#125;, js: &#123; options: &#123; &#125;, files: [jsSrc + '/*.js'], tasks: ['clean:js', 'jshint', 'uglify'] &#125;, html: &#123; options: &#123; &#125;, files: [htmlSrc + '/*.html'], tasks: ['clean:html', 'htmlhint', 'htmlmin'] &#125; &#125;, htmlhint: &#123; options: &#123; 'tagname-lowercase': true, 'attr-lowercase': true, 'attr-value-double-quotes': true, 'attr-value-not-empty': false, 'attr-no-duplication': true, 'doctype-first': true, 'tag-pair': true, 'tag-self-close': true, 'spec-char-escape': true, 'id-unique': true, 'src-not-empty': true, 'head-script-disabled': true, 'img-alt-require': false, 'doctype-html5': true, 'id-class-value': true, 'style-disabled': false, 'space-tab-mixed-disabled': true, 'id-class-ad-disabled': true, 'href-abs-or-rel': true, 'attr-unsafe-chars': true, 'force': true &#125;, files: [&#123; expand: true, cwd: htmlSrc, src: ['*.html'], dest: htmlDst &#125;] &#125;, shell: &#123; options: &#123; stderr: false &#125;, makeDir: &#123; command: 'mkdir test' &#125; &#125; &#125;); grunt.registerTask('default', ['build-css', 'build-js', 'build-html']); grunt.registerTask('concat-css', ['concat:css']); grunt.registerTask('clean-css', ['clean:css']); grunt.registerTask('build-css', ['clean:css', 'less', 'csslint', 'autoprefixer', 'cssmin']); grunt.registerTask('concat-js', ['concat:js']); grunt.registerTask('clean-js', ['clean:js']); grunt.registerTask('build-js', ['clean:js', 'jshint', 'uglify']); grunt.registerTask('clean-html', ['clean:html']); grunt.registerTask('build-html', ['clean:html', 'htmlhint', 'htmlmin']);&#125;; 以上内容需根据实际项目情况修改，仅作模板参考。 参考资料1.Grunt: 任务自动管理工具 2.三十分钟学会使用 Grunt 打包前端代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gulp 配置]]></title>
      <url>%2F2015%2F08%2F13%2Fgulp-configuration%2F</url>
      <content type="text"><![CDATA[Gulp 安装前提条件：电脑已经配置好 Node.js 的环境。 1$ npm install -g gulp-cli 进入工程目录，运行以下命令: 1$ npm install --save-dev gulp 除了安装 Gulp 以外，不同的项目还需要安装不同的 Gulp 插件模块。常用模块： 1234567891011121314$ npm install --save-dev gulp-load-plugins$ npm install --save-dev gulp-jshint$ npm install --save-dev gulp-csslint$ npm install --save-dev gulp-htmlhint$ npm install --save-dev gulp-watch$ npm install --save-dev gulp-shell$ npm install --save-dev gulp-concat$ npm install --save-dev gulp-clean$ npm install --save-dev gulp-less$ npm install --save-dev gulp-autoprefixer$ npm install --save-dev gulp-uglify$ npm install --save-dev gulp-cssmin$ npm install --save-dev gulp-imagemin$ npm install --save-dev gulp-htmlmin 或一行命令解决： 1$ npm install --save-dev gulp-load-plugins gulp-jshint gulp-csslint gulp-htmlhint gulp-watch gulp-shell gulp-concat gulp-clean gulp-less gulp-autoprefixer gulp-uglify gulp-cssmin gulp-imagemin gulp-htmlmin 模板文件每次都要输入这么多命令，有时候会记不住。其实我们只需要一个 package.json 文件就可以搞定： 1234567891011121314151617181920212223242526272829&#123; "name": "gulp-demo", "version": "1.0.0", "description": "just for learn gulp.", "devDependencies": &#123; "gulp": "^3.9.0", "gulp-autoprefixer": "^2.3.1", "gulp-clean": "^0.3.1", "gulp-concat": "^2.6.0", "gulp-csslint": "^0.1.5", "gulp-cssmin": "^0.1.7", "gulp-htmlhint": "^0.3.0", "gulp-htmlmin": "^1.1.3", "gulp-jshint": "^1.11.2", "gulp-less": "^3.0.3", "gulp-load-plugins": "^0.10.0", "gulp-shell": "^0.4.2", "gulp-uglify": "^1.2.0", "gulp-watch": "^4.3.4" &#125;, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "gulp" ], "author": "xLsDg", "license": "MIT"&#125; 每次需要使用的时候，将该文件放到项目文件夹下，在终端中输入 npm install 即可自动安装相应的模块。 配置模板安装完模块之后，还需要配置一下对应的工作参数。新建 gulpfile.js 文件与 package.json 文件同一个目录下，内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256var cssSrc = './less';var cssDst = './css';var jsSrc = './js/page';var jsDst = './js/dist';var htmlSrc = './views/**';var htmlDst = './html';var gulp = require('gulp');var plugins = require('gulp-load-plugins')(&#123; pattern: ['gulp-*', 'gulp.*'], config: __dirname + '/package.json', scope: ['devDependencies'], replaceString: /^gulp(-|\.)/, // what to remove from the name of the module when adding it to the context camelize: true, // if true, transforms hyphenated plugins names to camel case lazy: true, // whether the plugins should be lazy loaded on demand rename: &#123;&#125; // a mapping of plugins to rename &#125;);gulp.task('concat-css', function() &#123; return gulp.src([cssDst + '/*.css', '!' + cssDst + '/all.css']) .pipe(plugins.concat('all.css')) .pipe(gulp.dest(cssDst));&#125;);gulp.task('clean-css', function() &#123; return gulp.src([cssDst + '/*.css'], &#123; 'read': false &#125;) .pipe(plugins.clean(&#123; 'force': false &#125;));&#125;);gulp.task('build-css', ['clean-css'], function() &#123; return gulp.src([cssSrc + '/*.less', '!' + cssSrc + '/variable.less']) .pipe(plugins.less()) .pipe(plugins.csslint(&#123; 'important': false, 'adjoining-classes': false, 'known-properties': false, 'box-sizing': false, 'box-model': false, 'overqualified-elements': false, 'display-property-grouping': true, 'bulletproof-font-face': true, 'compatible-vendor-prefixes': false, 'regex-selectors': true, 'errors': true, 'duplicate-background-images': true, 'duplicate-properties': true, 'empty-rules': true, 'selector-max-approaching': true, 'gradients': true, 'fallback-colors': true, 'font-sizes': false, 'font-faces': true, 'floats': false, 'star-property-hack': false, 'outline-none': false, 'import': true, 'ids': true, 'underscore-property-hack': false, 'rules-count': true, 'qualified-headings': false, 'selector-max': true, 'shorthand': true, 'text-indent': true, 'unique-headings': false, 'universal-selector': true, 'unqualified-attributes': false, 'vendor-prefix': false, 'zero-units': true, 'force': true &#125;)) .pipe(plugins.csslint.reporter()) .pipe(plugins.autoprefixer(&#123; browsers: [ 'ie &gt;= 8', 'ff &gt;= 10', 'chrome &gt;= 20', 'safari &gt;= 7', 'opera &gt;= 10', 'ios &gt;= 7', 'android &gt;= 2.3' ] &#125;)) .pipe(plugins.cssmin(&#123; 'compatibility': 'ie8', 'noAdvanced': true &#125;)) .pipe(gulp.dest(cssDst));&#125;);gulp.task('concat-js', function() &#123; return gulp.src([jsDst + '/*.js', '!' + jsDst + '/all.js']) .pipe(plugins.concat('all.js')) .pipe(gulp.dest(jsDst));&#125;);gulp.task('clean-js', function() &#123; return gulp.src([jsDst + '/*.js'], &#123; 'read': false &#125;) .pipe(plugins.clean(&#123; 'force': false &#125;));&#125;);gulp.task('build-js', ['clean-js'], function() &#123; return gulp.src([jsSrc + '/*.js']) .pipe(plugins.jshint(&#123; 'jquery': true, // 检查预定义的全局变量，防止出现$未定义，该项根据实际代码修改 'bitwise': false, // 不检查位运算 'browser': true, // 通过浏览器内置的全局变量检测 'devel': true, // 允许对调试用的alert和console.log的调用 'camelcase': true, // 强制验证驼峰式命名 'curly': true, // 强制使用花括号 'eqeqeq': false, // 不强制使用===比较运算符 'es3': true, // 兼容es3规范，针对旧版浏览器编写的代码 'esnext': false, // 不使用最新的es6规范 'expr': true, // 允许未赋值的函数名表达式，例如console &amp;&amp; console.log(1) 'forin': false, // 不强制过滤遍历对象继承的属性 'freeze': false, // 不限制对内置对象的扩展 'immed': true, // 禁止未用括号包含立即执行函数 'indent': false, // 不强制缩进 'latedef': true, // 禁止先调用后定义 'maxdepth': false, // 不限制代码块嵌套层数 'maxparams': false, // 不限制函数参数个数 'newcap': false, // 不对首字母大写的函数强制使用new 'noarg': false, // 不禁止对arguments.caller和arguments.callee的调用 'noempty': false, // 不禁止空代码块 'nonew': false, // 允许直接new实例化而不赋值给变量 'plusplus': false, // 允许++和--运算符使用 'quotmark': 'single', // 字符串使用单引号 'scripturl': true, // 允许javascript伪协议的url 'smarttabs': false, // 允许混合tab和空格缩进 'strict': false, // 不强制使用es5严格模式 'sub': true, // 允许用[]形式访问对象属性 'undef': true, // 禁止明确未定义的变量调用，如果你的变量（myvar）是在其他文件中定义的，可以使用/*global myvar */绕过检测 'unused': false, // 允许定义没用的变量，在某些函数回调中，经常出现多个参数，但不一定会用 'multistr': false, // 禁止多行字符串，改用加号连接 'globals': &#123; 'jQuery': true, 'FastClick': true, 'define': true, 'unescape': true, 'require': true, 'iScroll': true, 'host': true &#125; &#125;)) .pipe(plugins.jshint.reporter('default')) .pipe(plugins.uglify()) .pipe(gulp.dest(jsDst));&#125;);gulp.task('clean-html', function() &#123; return gulp.src([htmlDst + '/*.html'], &#123; 'read': false &#125;) .pipe(plugins.clean(&#123; 'force': false &#125;));&#125;);gulp.task('build-html', ['clean-html'], function() &#123; return gulp.src([htmlSrc + '/*.html']) .pipe(plugins.htmlhint(&#123; 'tagname-lowercase': true, 'attr-lowercase': true, 'attr-value-double-quotes': true, 'attr-value-not-empty': false, 'attr-no-duplication': true, 'doctype-first': true, 'tag-pair': true, 'tag-self-close': true, 'spec-char-escape': true, 'id-unique': true, 'src-not-empty': true, 'head-script-disabled': true, 'img-alt-require': false, 'doctype-html5': true, 'id-class-value': true, 'style-disabled': false, 'space-tab-mixed-disabled': true, 'id-class-ad-disabled': true, 'href-abs-or-rel': true, 'attr-unsafe-chars': true, 'force': true &#125;)) .pipe(plugins.htmlhint.reporter()) .pipe(plugins.htmlmin(&#123; 'removeComments': false, 'removeCommentsFromCDATA': false, 'removeCDATASectionsFromCDATA': false, 'collapseWhitespace': true, 'conservativeCollapse': false, 'preserveLineBreaks': false, 'collapseBooleanAttributes': false, 'removeAttributeQuotes': false, 'removeRedundantAttributes': false, 'preventAttributesEscaping': false, 'useShortDoctype': false, 'removeEmptyAttributes': false, 'removeScriptTypeAttributes': false, 'removeStyleLinkTypeAttributes': false, 'removeOptionalTags': false, 'removeIgnored': false, 'removeEmptyElements': false, 'lint': false, 'keepClosingSlash': false, 'caseSensitive': false, 'minifyJS': false, 'minifyCSS': false, 'minifyURLs': false, 'ignoreCustomComments': [], 'processScripts': [], 'maxLineLength': [], 'customAttrAssign': [], 'customAttrSurround': [], 'customAttrCollapse': [] &#125;)) .pipe(gulp.dest(htmlDst));&#125;);gulp.task('clean-all', ['clean-css', 'clean-js', 'clean-html'], function() &#123; console.log('Clean all files finish.');&#125;);gulp.task('build-all', ['build-css', 'build-js', 'build-html'], function() &#123; console.log('Build all files finish.');&#125;);gulp.task('no-html', ['build-css', 'build-js'], function() &#123; console.log('Build all files finish.');&#125;);gulp.task('no-js', ['build-css', 'build-html'], function() &#123; console.log('Build all files finish.');&#125;);gulp.task('no-css', ['build-js', 'build-html'], function() &#123; console.log('Build all files finish.');&#125;);gulp.task('watch', function() &#123; gulp.watch([cssSrc + '/*.less', jsSrc + '/*.js', htmlSrc + '/*.html'], ['build-all']).on('change', function(event) &#123; console.log('Event type: ' + event.type); console.log('Event path: ' + event.path); &#125;);&#125;);gulp.task('default', ['build-all'], function() &#123; console.log('Build all files finish.');&#125;); 以上内容需根据实际项目情况小做修改即可。 参考资料1.Gulp：任务自动管理工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[花密PHP核心代码]]></title>
      <url>%2F2015%2F06%2F21%2Fflower-password-php-core-code%2F</url>
      <content type="text"><![CDATA[花密简介“花密”提供一种简单的密码管理方法，你只需要记住一个“记忆密码”，为不同的账号设置不同的“区分代号”，然后通过“花密”计算就可以得到不同的复杂密码。 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpif (isset($_GET["pwd"]) &amp;&amp; isset($_GET["key"])) &#123; $pwd = $_GET["pwd"]; $key = $_GET["key"]; $len = isset($_GET["len"]) ? $_GET["len"] : 16;&#125; else if (isset($_POST["pwd"]) &amp;&amp; isset($_POST["key"])) &#123; $pwd = $_POST["pwd"]; $key = $_POST["key"]; $len = isset($_POST["len"]) ? $_POST["len"] : 16;&#125; else &#123; echo ""; exit(0);&#125;if ($pwd &amp;&amp; $key &amp;&amp; $len) &#123; $objFP = new FlowerPassword(); $code = $objFP-&gt;fpCode($pwd, $key, $len); unset($objFP); if ($code !== false) &#123; echo $code; &#125; else &#123; echo ""; &#125;&#125; else &#123; echo "";&#125;class FlowerPassword &#123; public function fpCode($password, $key, $length = 16) &#123; if ($password &amp;&amp; $key &amp;&amp; (1 &lt; $length) &amp;&amp; ($length &lt; 33)) &#123; $hmd5 = hash_hmac('md5', $password, $key); $rule = str_split(hash_hmac('md5', $hmd5, "kise")); $source = str_split(hash_hmac('md5', $hmd5, "snow")); $str = "sunlovesnow1990090127xykab"; for ($i = 0; $i &lt; 32; $i++) &#123; if (!is_numeric($source[$i])) &#123; if (stripos($str, $rule[$i]) !== false) &#123; $source[$i] = strtoupper($source[$i]); &#125; &#125; &#125; if (is_numeric($source[0])) &#123; $source[0] = 'K'; &#125; $code = substr(implode($source), 0, $length); return $code; &#125; else &#123; return false; &#125; &#125;&#125;?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[花密C语言核心代码]]></title>
      <url>%2F2015%2F06%2F10%2Fflower-password-c-core-code%2F</url>
      <content type="text"><![CDATA[准备工作下载依赖库：spaniakos 的 ArduinoMD5 。 选择这个库的原因是代码可以在 Arduino 或 Raspberry Pi 上运行。 头文件包含拷贝三个文件：MD5_config.h 、 MD5.h 、 MD5.cpp 到项目文件夹，并在源代码文件中包含： 1#include "MD5.h" 核心代码JavaScript的isNaN()函数C语言实现： 1234567char isNaN(char ch) &#123; if ('0' &lt;= ch &amp;&amp; ch &lt;= '9') &#123; return 0; &#125; else &#123; return 1; &#125;&#125; 字母字符转大写： 123456char toupper(char c) &#123; if (('a' &lt;= c) &amp;&amp; (c &lt;= 'z')) &#123; c = c - ('a' - 'A'); &#125; return c;&#125; 花密计算核心代码： 1234567891011121314151617181920212223242526272829303132333435363738394041char fpCode(const char* password, char* key, char code[33], unsigned char length) &#123; unsigned char pwdLen = strlen(password); unsigned char keyLen = strlen(key); if ((1 &gt; pwdLen) || (1 &gt; keyLen) || (1u &gt; length) || (length &gt; 32u)) &#123; return 0; &#125; MD5 hashMD5; char* pHmd5 = hashMD5.hmac_md5(password, pwdLen, key, keyLen); char hmd5[32]; memcpy(hmd5, pHmd5, 32); char* pKise = "kise"; char* pRule = hashMD5.hmac_md5(hmd5, 32, pKise, 4); char rule[32]; memcpy(rule, pRule, 32); char* pSnow = "snow"; char* pSource = hashMD5.hmac_md5(hmd5, 32, pSnow, 4); char source[32]; memcpy(source, pSource, 32); for (unsigned char i = 0; i &lt; 32; i++) &#123; if (isNaN(source[i])) &#123; if (strchr("sunlovesnow1990090127xykab", rule[i]) != NULL) &#123; source[i] = toupper(source[i]); &#125; &#125; &#125; if (isNaN(source[0]) == 0) &#123; source[0] = 'K'; &#125; memset(code, 0, 33); memcpy(code, source, sizeof(char) * length); return 1;&#125; 使用方法生成 code[] 的数组为什么不是32，而是33？ 是为了输出字符串结果，特意多加了一个 &#39;\0&#39; 位。 123456789char* p = "password";char* k = "key";char c[33];if (fpCode(p, k, c, 16) == 1) &#123; printf("fpCode=%s", c);&#125; else &#123; printf("Error!");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[花密Python核心代码]]></title>
      <url>%2F2015%2F06%2F09%2Fflower-password-python-core-code%2F</url>
      <content type="text"><![CDATA[花密简介“花密”提供一种简单的密码管理方法，你只需要记住一个“记忆密码”，为不同的账号设置不同的“区分代号”，然后通过“花密”计算就可以得到不同的复杂密码。 Python 2.x 核心代码1234567891011121314151617181920212223import sysimport hmacdef generateFPCode(password, key, length = 16): if (1 &gt; len(password.strip())) or (1 &gt; len(key.strip())) or (1 &gt; length) or (length &gt; 32): return; hmd5 = hmac.new(key, password).hexdigest(); rule = list(hmac.new("kise", hmd5).hexdigest()); source = list(hmac.new("snow", hmd5).hexdigest()); for i in range(0, 32): if not(source[i].isdigit()): if rule[i] in "sunlovesnow1990090127xykab": source[i] = source[i].upper(); code = "".join(source[1:length]); if not(source[0].isdigit()): code = source[0] + code; else: code = "K" + code; return code; Python 3.x 核心代码1234567891011121314151617181920212223242526import sysimport hmacdef generateFPCode(password, key, length = 16): if (1 &gt; len(password.strip())) or (1 &gt; len(key.strip())) or (1 &gt; length) or (length &gt; 32): return; password = password.encode(encoding="utf-8"); key = key.encode(encoding="utf-8"); hmd5 = hmac.new(key, password).hexdigest().encode(encoding="utf-8"); rule = list(hmac.new("kise".encode(encoding="utf-8"), hmd5).hexdigest()); source = list(hmac.new("snow".encode(encoding="utf-8"), hmd5).hexdigest()); for i in range(0, 32): if not(source[i].isdigit()): if rule[i] in "sunlovesnow1990090127xykab": source[i] = source[i].upper(); code = "".join(source[1:length]); if not(source[0].isdigit()): code = source[0] + code; else: code = "K" + code; return code;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[花密JavaScript核心代码]]></title>
      <url>%2F2015%2F06%2F08%2Fflower-password-javascript-core-code%2F</url>
      <content type="text"><![CDATA[花密简介“花密”提供一种简单的密码管理方法，你只需要记住一个“记忆密码”，为不同的账号设置不同的“区分代号”，然后通过“花密”计算就可以得到不同的复杂密码。 核心代码123456789101112131415161718192021222324&lt;script src="https://raw.githubusercontent.com/blueimp/JavaScript-MD5/master/js/md5.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; function generateFPCode(password, key, length) &#123; length = length || 16; if (password &amp;&amp; key &amp;&amp; (1 &lt; length) &amp;&amp; (length &lt; 33)) &#123; var hmd5 = md5(password, key); var rule = md5(hmd5, 'kise').split(""); var source = md5(hmd5, 'snow').split(""); var str = "sunlovesnow1990090127xykab"; for (var i = 0; i &lt; 32; i++) &#123; if (isNaN(source[i])) &#123; if (str.search(rule[i]) &gt; -1) &#123; source[i] = source[i].toUpperCase(); &#125; &#125; &#125; var code32 = source.join(""); var code01 = code32.slice(0, 1); code32 = (isNaN(code01) ? code01 : "K") + code32.slice(1, length); return code32; &#125; &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记]]></title>
      <url>%2F2015%2F06%2F03%2Fjavascript-study-notes%2F</url>
      <content type="text"><![CDATA[JavaScript 用法 &lt;script&gt; 标签 123&lt;script&gt; alert("我的第一个 JavaScript");&lt;/script&gt; &lt;head&gt; 中的 JavaScript 函数 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; function myFunction() &#123; document.getElementById("demo").innerHTML="我的第一个 JavaScript 函数"; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的 Web 页面&lt;/h1&gt; &lt;p id="demo"&gt;一个段落&lt;/p&gt; &lt;button type="button" onclick="myFunction()"&gt;尝试一下&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; &lt;body&gt; 中的 JavaScript 函数 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h1&gt;我的 Web 页面&lt;/h1&gt; &lt;p id="demo"&gt;一个段落&lt;/p&gt; &lt;button type="button" onclick="myFunction()"&gt;尝试一下&lt;/button&gt; &lt;script&gt; function myFunction() &#123; document.getElementById("demo").innerHTML="我的第一个 JavaScript 函数"; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 外部的 JavaScript 外部脚本不能包含 &lt;script&gt; 标签。 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script src="myScript.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 输出 写到 HTML 文档 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h1&gt;我的第一个 Web 页面&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;button onclick="myFunction()"&gt;点我&lt;/button&gt; &lt;script&gt; function myFunction() &#123; document.write(Date()); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 写到控制台 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h1&gt;我的第一个 Web 页面&lt;/h1&gt; &lt;script&gt; a = 5; b = 6; c = a + b; console.log(c); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 语句 JavaScript 对大小写敏感 函数 getElementById 与 getElementbyID 是不同的，同样，变量 myVariable 与 MyVariable 也是不同的。 对代码行进行折行 可以在文本字符串中使用反斜杠对代码行进行换行。 12document.write("你好 \世界!"); JavaScript 注释 JavaScript 单行注释 1234// 输出标题：document.getElementById("myH1").innerHTML="欢迎来到我的主页";// 输出段落：document.getElementById("myP").innerHTML="这是我的第一个段落。"; JavaScript 多行注释 1234567/*下面的这些代码会输出一个标题和一个段落并将代表主页的开始*/document.getElementById("myH1").innerHTML="欢迎来到我的主页";document.getElementById("myP").innerHTML="这是我的第一个段落。"; JavaScript 变量变量必须以字母开头；变量也能以 $ 和 _ 符号开头；变量名称对大小写敏感。 声明（创建） JavaScript 变量 1var carname="Volvo"; 一条语句，多个变量 1var lastname="Doe", age=30, job="carpenter"; Value = undefined 未使用值来声明的变量，其值实际上是 undefined。 1var carname; 重新声明 JavaScript 变量 如果重新声明 JavaScript 变量，该变量的值不会丢失。 12var carname="Volvo";var carname; JavaScript 数据类型字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined）。 JavaScript 拥有动态类型 123var x; // x 为 undefinedvar x = 5; // 现在 x 为数字var x = "John"; // 现在 x 为字符串 JavaScript 字符串 123var answer="It's alright";var answer="He is called 'Johnny'";var answer='He is called "Johnny"'; JavaScript 数字 12var y=123e5; // 12300000var z=123e-5; // 0.00123 JavaScript 布尔 12var x=true;var y=false; JavaScript 数组 123456var cars1=new Array();cars1[0]="Saab";cars1[1]="Volvo";cars1[2]="BMW";var cars2=new Array("Saab","Volvo","BMW");var cars3=["Saab","Volvo","BMW"]; JavaScript 对象 123var person=&#123;firstname:"John", lastname:"Doe", id:5566&#125;;var name1=person.lastname;var name2=person["lastname"]; Undefined 和 Null Undefined 这个值表示变量不含有值，可以通过将变量的值设置为 null 来清空变量。 12cars=null;person=null; 声明变量类型 12345var carname=new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派之Node.js环境配置]]></title>
      <url>%2F2015%2F06%2F02%2Finstall-node-js-on-the-raspberry-pi%2F</url>
      <content type="text"><![CDATA[一键安装优点：简单、快捷、方便、省事。 缺点：以这个方法安装的Node.js版本比较低。 1$ sudo aptitude install nodejs 源码安装优点：能安装最新版或任意版本的Node.js。 缺点：源码编译时间的时间比较长。 123456$ wget http://nodejs.org/dist/node-latest.tar.gz$ tar -xvzf node-latest.tar.gz$ cd node-latest/$ ./configure$ make$ sudo make install 软件包安装优点：简单、快捷、方便、省事，可以安装到比较新的版本。 缺点：暂未发现。 12$ wget http://node-arm.herokuapp.com/node_latest_armhf.deb$ sudo dpkg -i node_latest_armhf.deb 通过NVM安装优点：官网v0.10.28之前的任意版本都可以直接安装；可以任意切换不同版本； 缺点：v0.10.28之后的版本都要以源码编译的方式安装。 安装NVM： 1$ git clone https://github.com/creationix/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` 编辑 ~/.bashrc 或 ~/.profile 或 ~/.zshrc 或 ~/.bash_profile 文件（如果存在的话），添加下面代码到最后一行： 123456if [ -f ~/.nvm/nvm.sh ]; then export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node export NVM_IOJS_ORG_MIRROR=http://npm.taobao.org/mirrors/iojs . ~/.nvm/nvm.sh [[ -r ~/.nvm/bash_completion ]] &amp;&amp; . ~/.nvm/bash_completionfi 通过以下类似命令安装任意版本的Node.js，以v0.10.28为例： 1$ nvm install v0.10.28 切换或使用特定版本的Node.js： 1$ nvm use v0.10.27 查看使用的Node.js版本： 1$ nvm ls 通过n模块更新Node.js 安装n模块: 1$ sudo npm install -g n 更新最新版Node.js: 1$ sudo n latest 安装CNPM 具体参考：淘宝 NPM 镜像 1$ npm install -g cnpm --registry=http://registry.npm.taobao.org 通过CNPM安装模块 1$ cnpm install [name] 解决NPM慢的问题 使用淘宝NPM镜像： 1$ sudo npm config set registry http://registry.npm.taobao.org/ 使用代理： 12$ sudo npm config set proxy http://hx.gy:1080$ sudo npm config set https-proxy http://hx.gy:1080 查看配置： 1$ sudo npm config list 安装io.jsio.js的安装相对比较简单，官方已有编译好的二进制文件下载。 访问io.js官网，选择相应的系统平台安装包，然后输入以下命令（这个方法卸载的时候比较麻烦）： 123456789$ cd ~$ wget https://iojs.org/dist/latest/iojs-v3.3.0-linux-armv7l.tar.gz$ tar -xvzf iojs-v3.3.0-linux-armv7l.tar.gz$ cd iojs-v3.3.0-linux-armv7l/$ rm -f ./*.md$ rm -f ./LICENSE$ sudo cp -rf --remove-destination ./* /usr/local/$ cd ..$ rm -rf iojs-v3.3.0-linux-armv7l/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《SQL必知必会》学习笔记]]></title>
      <url>%2F2015%2F06%2F01%2Fsams-teach-yourself-sql-in-10-minutes-study-notes%2F</url>
      <content type="text"><![CDATA[前言 到官网下载实验数据脚本：Sams Teach Yourself SQL in 10 Minutes。本文以 MySQL 为例，对应的脚本文件下载地址：MySQL。 终端中运行 mysql -uroot -p 登录 MySQL，执行以下命令创建数据库： 1CREATE DATABASE sql_test; 运行 create.txt SQL 脚本文件创建表： 1$ mysql -uroot -p sql_test &lt; create.txt 运行 populate.txt SQL 脚本文件插入数据： 1$ mysql -uroot -p sql_test &lt; populate.txt 了解 SQL 数据库：保存有组织的数据容器（通常是一个文件或一组文件）。 表：某种特定类型数据的结构化清单。 列：表中的一个字段，所有表都是由一个或多个列组成的。 行：表中的一个记录。 主键：一列（或一组列），其值能够唯一标识表中每一行。 检索数据 检索单个列 12SELECT prod_nameFROM Products; 检索多个列 12SELECT prod_id, prod_name, prod_priceFROM Products; 检索所有列 12SELECT *FROM Products; 检索不同的值 12SELECT DISTINCT vend_idFROM Products; 限制结果 1234567SELECT prod_nameFROM ProductsLIMIT 2 OFFSET 3;/* OR */SELECT prod_nameFROM ProductsLIMIT 3, 2; 使用注释 123456789101112SELECT prod_name -- 行内注释FROM Products;# 单行注释SELECT prod_nameFROM Products;/* 多行注释SELECT prod_name, vend_idFROM Products; */SELECT prod_nameFROM Produncts; 排序检索数据 排序数据 123SELECT prod_nameFROM ProductsORDER BY prod_name; 按多个列排序 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price, prod_name; 按列位置排序 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY 2, 3; 指定排序方向 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC, prod_name DESC; 过滤数据 检查单个值 123SELECT prod_name, prod_priceFROM ProductsWHERE prod_price &lt; 10; 不匹配检查 123SELECT vend_id, prod_nameFROM ProductsWHERE vend_id &lt;&gt; 'DLL01'; 范围值检查 123SELECT prod_name, prod_priceFROM ProductsWHERE prod_price BETWEEN 5 AND 10; 空值检查 123SELECT cust_nameFROM CustomersWHERE cust_email IS NULL; 高级数据过滤 AND 操作符 123SELECT prod_id, prod_price, prod_nameFROM ProductsWHERE vend_id = 'DLL01' AND prod_price &lt;= 4; OR 操作符 123SELECT prod_name, prod_priceFROM ProductsWHERE vend_id = 'DLL01' OR vend_id = 'BRS01'; 求值顺序 123SELECT prod_name, prod_priceFROM ProductsWHERE (vend_id = 'DLL01' OR vend_id = 'BRS01') AND prod_price &gt;= 10; IN 操作符 1234SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN ( 'DLL01', 'BRS01' )ORDER BY prod_name; NOT 操作符 1234SELECT prod_nameFROM ProductsWHERE NOT vend_id = 'DLL01'ORDER BY prod_name; 用通配符进行过滤 百分号（%）通配符 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE '%bean bag%'; 下划线（_）通配符 只匹配单个字符： 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE '__ inch teddy bear'; 方括号（[]）通配符 匹配方括号中的每个字符： 1234SELCET cust_contactFROM CustomersWHERE cust_contact LIKE '[JM]%'ORDER BY cust_contact; 否定方括号中的每个字符： 1234SELCET cust_contactFROM CustomersWHERE cust_contact LIKE '[^JM]%'ORDER BY cust_contact;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派之SD卡备份与还原]]></title>
      <url>%2F2015%2F05%2F31%2Fraspberry-pi-sd-card-backup-and-recovery%2F</url>
      <content type="text"><![CDATA[前言本文主要介绍以最小的方式完整备份树莓派SD卡镜像的方法。 准备工作在树莓派的终端里运行下面这条命令，安装必备工具： 1$ sudo aptitude install dosfstools dump parted kpartx screen exfat-fuse fuse-utils ntfs-3g 说明： dosfstools：FAT32分区格式化工具。 dump：dump 和 restore 备份工具。 screen：ssh远程会话管理工具。 parted，kpartx：虚拟磁盘工具。 exfat-fuse：挂载exFAT格式优盘工具。 fuse-utils，ntfs-3g：挂载NTFS格式优盘工具。 优盘编号备份需要一个能够装下整个树莓派镜像的优盘或移动硬盘，在终端中运行 sudo fdisk -l，确认已经插上的优盘或移动硬盘编号为 /dev/sda1。若不是则记下具体编号，待会修改脚本中内容。 脚本配置备份镜像文件名，修改 raspberrypi.img 即可： 1IMG_PATH="$&#123;USB_PATH&#125;/raspberrypi.img" 挂载优盘，修改 /dev/sda1 为具体的编号： 1sudo mount -o uid=pi,gid=pi /dev/sda1 $&#123;USB_PATH&#125; 生成镜像文件大小，默认4G=4096×1048576字节(b)。想要生成?G，只需要修改count的值即可，count=?×1024×1024×1024÷4096： 1sudo dd if=/dev/zero of=$&#123;IMG_PATH&#125; bs=4096 count=1048576 boot分区卷标： 1sudo dosfslabel $&#123;bootPath&#125; "rpi-boot" 系统分区卷标： 1sudo e2label $&#123;rootPath&#125; "rpi-sys" 备份脚本将以下内容保存为 backup.sh 文件，并赋予执行权限 sudo chmod +x backup.sh。在终端中输入 screen -S backup 创建backup会话，找到 backup.sh 文件所在位置执行 ./backup.sh 开始备份树莓派的SD卡全部内容，备份后的镜像文件 raspberrypi.img 保存在优盘或移动硬盘的根目录下。最后使用快捷键Ctrl+a+d(即按住Ctrl，依次再按a,d)离开backup会话。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/bin/shUSB_PATH="/mnt/usb"IMG_PATH="$&#123;USB_PATH&#125;/raspberrypi.img"TMP_BOOT="/mnt/tmp_boot"TMP_ROOT="/mnt/tmp_root"if [ ! -d $&#123;USB_PATH&#125; ]; then sudo mkdir $&#123;USB_PATH&#125;fisudo mount -o uid=pi,gid=pi /dev/sda1 $&#123;USB_PATH&#125;if [ -f $&#123;IMG_PATH&#125; ]; then sudo rm -f $&#123;IMG_PATH&#125;fisudo dd if=/dev/zero of=$&#123;IMG_PATH&#125; bs=4096 count=1048576sudo parted -s $&#123;IMG_PATH&#125; -- mklabel msdossudo parted -s $&#123;IMG_PATH&#125; -- mkpart primary fat32 8192s 122879ssudo parted -s $&#123;IMG_PATH&#125; -- mkpart primary ext4 122880s -1sudo parted -s $&#123;IMG_PATH&#125; printloopDev=`sudo losetup -f --show $&#123;IMG_PATH&#125;`devPath=`sudo kpartx -va $&#123;loopDev&#125; | sed -E 's/.*(loop[0-9])p.*/\1/g' | head -1`devPath="/dev/mapper/$&#123;devPath&#125;"bootPath="$&#123;devPath&#125;p1"sudo mkfs.vfat $&#123;bootPath&#125;sudo dosfslabel $&#123;bootPath&#125; "rpi-boot"rootPath="$&#123;devPath&#125;p2"sudo mkfs.ext4 $&#123;rootPath&#125;sudo e2label $&#123;rootPath&#125; "rpi-sys"if [ ! -d $&#123;TMP_BOOT&#125; ]; then sudo mkdir $&#123;TMP_BOOT&#125;fisudo umount $&#123;TMP_BOOT&#125;sudo mount -t vfat $&#123;bootPath&#125; $&#123;TMP_BOOT&#125;sudo cp -rfp /boot/* $&#123;TMP_BOOT&#125;/sudo umount $&#123;TMP_BOOT&#125;if [ ! -d $&#123;TMP_ROOT&#125; ]; then sudo mkdir $&#123;TMP_ROOT&#125;fisudo umount $&#123;TMP_ROOT&#125;sudo mount -t ext4 $&#123;rootPath&#125; $&#123;TMP_ROOT&#125;cd $&#123;TMP_ROOT&#125;sudo dump -0uaf - / | sudo restore -rf -cd ~sudo umount $&#123;TMP_ROOT&#125;sudo kpartx -d $&#123;loopDev&#125;sudo losetup -d $&#123;loopDev&#125;sudo umount $&#123;USB_PATH&#125;#sudo rm -rf $&#123;TMP_BOOT&#125;#sudo rm -rf $&#123;TMP_ROOT&#125; 还原镜像Windows下还原镜像可以使用以下工具： Win32DiskImager，USB Image Tool（推荐），HDDRawCopy（可以进一步压缩img镜像文件）。 新系统运行还原后的新系统第一次运行记得执行以下命令，然后选择 Expand Filesystem 扩展新SD卡未使用的空间。 1$ sudo raspi-config 脚本说明镜像文件分区8192s 和 122879s 是根据官方镜像文件分区得到的数据，也就是第一个boot分区大小。-1 代表直到镜像文件结尾。 1234sudo parted -s $&#123;IMG_PATH&#125; -- mklabel msdossudo parted -s $&#123;IMG_PATH&#125; -- mkpart primary fat32 8192s 122879ssudo parted -s $&#123;IMG_PATH&#125; -- mkpart primary ext4 122880s -1sudo parted -s $&#123;IMG_PATH&#125; print 挂载并格式化虚拟磁盘1234567891011loopDev=`sudo losetup -f --show $&#123;IMG_PATH&#125;`devPath=`sudo kpartx -va $&#123;loopDev&#125; | sed -E 's/.*(loop[0-9])p.*/\1/g' | head -1`devPath="/dev/mapper/$&#123;devPath&#125;"bootPath="$&#123;devPath&#125;p1"sudo mkfs.vfat $&#123;bootPath&#125;sudo dosfslabel $&#123;bootPath&#125; "rpi-boot"rootPath="$&#123;devPath&#125;p2"sudo mkfs.ext4 $&#123;rootPath&#125;sudo e2label $&#123;rootPath&#125; "rpi-sys" 备份boot分区12345678if [ ! -d $&#123;TMP_BOOT&#125; ]; then sudo mkdir $&#123;TMP_BOOT&#125;fisudo umount $&#123;TMP_BOOT&#125;sudo mount -t vfat $&#123;bootPath&#125; $&#123;TMP_BOOT&#125;sudo cp -rfp /boot/* $&#123;TMP_BOOT&#125;/sudo umount $&#123;TMP_BOOT&#125; 备份系统分区使用 dump 和 restore 工具配合备份系统： 12345678910if [ ! -d $&#123;TMP_ROOT&#125; ]; then sudo mkdir $&#123;TMP_ROOT&#125;fisudo umount $&#123;TMP_ROOT&#125;sudo mount -t ext4 $&#123;rootPath&#125; $&#123;TMP_ROOT&#125;cd $&#123;TMP_ROOT&#125;sudo dump -0uaf - / | sudo restore -rf -cd ~sudo umount $&#123;TMP_ROOT&#125; 卸载虚拟磁盘12sudo kpartx -d $&#123;loopDev&#125;sudo losetup -d $&#123;loopDev&#125; 修改镜像文件明白了以上脚本内容，以后我们想要修改镜像文件里的内容可以使用以下的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/shUSB_PATH="/mnt/usb"IMG_PATH="$&#123;USB_PATH&#125;/raspberrypi.img"BOOT_PATH="/mnt/tmp_boot"ROOT_PATH="/mnt/tmp_root"if [ ! -d $&#123;USB_PATH&#125; ]; then sudo mkdir $&#123;USB_PATH&#125;fisudo mount -o uid=pi,gid=pi /dev/sda1 $&#123;USB_PATH&#125;loopDev=`sudo losetup -f --show $&#123;IMG_PATH&#125;`devPath=`sudo kpartx -va $&#123;loopDev&#125; | sed -E 's/.*(loop[0-9])p.*/\1/g' | head -1`devPath="/dev/mapper/$&#123;devPath&#125;"bootPath="$&#123;devPath&#125;p1"if [ ! -d $&#123;BOOT_PATH&#125; ]; then sudo mkdir $&#123;BOOT_PATH&#125;fisudo umount $&#123;BOOT_PATH&#125;sudo mount -t vfat $&#123;bootPath&#125; $&#123;BOOT_PATH&#125;rootPath="$&#123;devPath&#125;p2"if [ ! -d $&#123;ROOT_PATH&#125; ]; then sudo mkdir $&#123;ROOT_PATH&#125;fisudo umount $&#123;ROOT_PATH&#125;sudo mount -t ext4 $&#123;rootPath&#125; $&#123;ROOT_PATH&#125;echo "bootPath: $&#123;BOOT_PATH&#125;"echo "rootPath: $&#123;ROOT_PATH&#125;"echo "sudo umount $&#123;BOOT_PATH&#125;"echo "sudo umount $&#123;ROOT_PATH&#125;"echo "sudo kpartx -d $&#123;loopDev&#125;"echo "sudo losetup -d $&#123;loopDev&#125;"echo "sudo umount $&#123;USB_PATH&#125;" 修改完成之后记得执行最后那几行打印的命令，卸载虚拟磁盘，保存结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习笔记]]></title>
      <url>%2F2015%2F05%2F28%2Fhtml-study-notes%2F</url>
      <content type="text"><![CDATA[HTML 简单模板123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; HTML &lt;!DOCTYPE&gt; 声明HTML 51&lt;!DOCTYPE html&gt; HTML 4.01 Strict这个 DTD 包含所有 HTML 元素和属性，但不包括表象或过时的元素（如 font ）。框架集是不允许的。 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML 4.01 Transitional这个 DTD 包含所有 HTML 元素和属性，包括表象或过时的元素（如 font ）。框架集是不允许的。 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; HTML 4.01 Frameset这个 DTD 与 HTML 4.01 Transitional 相同，但是允许使用框架集内容。 1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; XHTML 1.0 Strict这个 DTD 包含所有 HTML 元素和属性，但不包括表象或过时的元素（如 font ）。框架集是不允许的。结构必须按标准格式的 XML 进行书写。 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; XHTML 1.0 Transitional这个 DTD 包含所有 HTML 元素和属性，包括表象或过时的元素（如 font ）。框架集是不允许的。结构必须按标准格式的 XML 进行书写。 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; XHTML 1.0 Frameset这个 DTD 与 XHTML 1.0 Transitional 相同，但是允许使用框架集内容。 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; XHTML 1.1这个 DTD 与 XHTML 1.0 Strict 相同，但是允许您添加模块（例如为东亚语言提供 ruby 支持）。 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt; HTML 标题HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt;标签来定义的. 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; HTML 段落12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt; HTML 链接使用 Target 属性，你可以定义被链接的文档在何处显示。 1&lt;a href="http://www.xxx.com/" target="_blank"&gt;Welcome&lt;/a&gt; 在HTML文档中创建一个链接到’有用的提示部分(id=”tips”)’： 1&lt;a href="#tips"&gt;Visit the Useful Tips Section&lt;/a&gt; 从另一个页面创建一个链接到’有用的提示(id=”tips”)部分’： 12&lt;a href="http://www.xxx.com/html_links.htm#tips"&gt;Visit the Useful Tips Section&lt;/a&gt; HTML 图像&lt;img&gt; 是空标签，意思是说，它只包含属性，并且没有闭合标签。 alt 属性在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。 1&lt;img src="pulpit.jpg" alt="Pulpit rock" width="304" height="228"&gt; HTML 图像标签 标签 描述 &lt;img&gt; 定义图像 &lt;map&gt; 定义图像地图 &lt;area&gt; 定义图像地图中的可点击区域 HTML 空元素在开始标签中添加斜杠，比如 &lt;br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 HTML 属性 属性 描述 class 为html元素定义一个或多个类名（classname）(类名从样式文件引入) id 定义元素的唯一id style 规定元素的行内样式（inline style） title 描述了元素的额外信息 (作为工具条使用) HTML 水平线12345&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt; HTML 注释1&lt;!-- 这是一个注释 --&gt; HTML 文本格式化标签 标签 描述 &lt;b&gt; 定义粗体文本 &lt;em&gt; 定义着重文字 &lt;i&gt; 定义斜体字 &lt;small&gt; 定义小号字 &lt;strong&gt; 定义加重语气 &lt;sub&gt; 定义下标字 &lt;sup&gt; 定义上标字 &lt;ins&gt; 定义插入字 &lt;del&gt; 定义删除字 HTML “计算机输出” 标签 标签 描述 &lt;code&gt; 定义计算机代码 &lt;kbd&gt; 定义键盘码 &lt;samp&gt; 定义计算机代码样本 &lt;var&gt; 定义变量 &lt;pre&gt; 定义预格式文本 HTML 引文, 引用, 及标签定义 标签 描述 &lt;abbr&gt; 定义缩写 &lt;address&gt; 定义地址 &lt;bdo&gt; 定义文字方向 &lt;blockquote&gt; 定义长的引用 &lt;q&gt; 定义短的引用语 &lt;cite&gt; 定义引用、引证 &lt;dfn&gt; 定义一个定义项目 HTML &lt;head&gt; 元素可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt;, &lt;base&gt;。 HTML &lt;title&gt; 元素&lt;title&gt; 标签定义了浏览器工具栏的标题、当网页添加到收藏夹时，显示在收藏夹中的标题、显示在搜索引擎结果页面的标题。 HTML &lt;base&gt; 元素&lt;base&gt; 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接: 123&lt;head&gt;&lt;base href="http://www.xxx.com/images/" target="_blank"&gt;&lt;/head&gt; HTML &lt;link&gt; 元素&lt;link&gt; 标签定义了文档与外部资源之间的关系，通常用于链接到样式表: 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; HTML &lt;style&gt; 元素&lt;style&gt; 标签定义了HTML文档的样式文件引用地址. 123456&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color:yellow&#125;p &#123;color:blue&#125;&lt;/style&gt;&lt;/head&gt; HTML &lt;meta&gt; 元素&lt;meta&gt; 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。&lt;meta&gt; 一般放置于 &lt;head&gt; 区域。 为搜索引擎定义关键词: 1&lt;meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript"&gt; 为网页定义描述内容: 1&lt;meta name="description" content="Free Web tutorials on HTML and CSS"&gt; 定义网页作者: 1&lt;meta name="author" content="Hege Refsnes"&gt; 每30秒中刷新当前页面: 1&lt;meta http-equiv="refresh" content="30"&gt; HTML &lt;script&gt; 元素&lt;script&gt; 标签可用于加载外部脚本文件，如：JavaScript。 CSS 内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。 1&lt;p style="color:blue;margin-left:20px;"&gt;This is a paragraph.&lt;/p&gt; CSS 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在 &lt;head&gt; 部分通过 &lt;style&gt; 标签定义内部样式表。 123456&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color:yellow;&#125;p &#123;color:blue;&#125;&lt;/style&gt;&lt;/head&gt; CSS 外部样式表当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; HTML 表格标签 标签 描述 &lt;table&gt; 定义表格 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 &lt;caption&gt; 定义表格标题 &lt;colgroup&gt; 定义表格列的组 &lt;col&gt; 定义用于表格列的属性 &lt;thead&gt; 定义表格的页眉 &lt;tbody&gt; 定义表格的主体 &lt;tfoot&gt; 定义表格的页脚 HTML 列表标签有序列表 start 属性：a、A、i、I。 无序列表 type 属性：disc 实心圆、 circle 空心圆、 square 实心方块。 标签 描述 &lt;ol&gt; 定义有序列表 &lt;ul&gt; 定义无序列表 &lt;li&gt; 定义列表项 &lt;dl&gt; 定义自定义列表 &lt;dt&gt; 定义自定义列表项目 &lt;dd&gt; 定义自定义列表的描述 HTML 区块元素块级元素在浏览器显示时，通常会以新行来开始（和结束）。 实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;。 HTML 内联元素内联元素在显示时通常不会以新行开始。 实例: &lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;。 HTML &lt;div&gt; 元素&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 HTML &lt;span&gt; 与元素HTML &lt;span&gt; 元素是内联元素，可用作文本的容器，也没有特定的含义。 HTML 表单标签 标签 描述 &lt;form&gt; 定义供用户输入的表单 &lt;input&gt; 定义输入域 &lt;textarea&gt; 定义文本域 (一个多行的输入控件) &lt;label&gt; 定义了 &lt;input&gt; 元素的标签，一般为输入标题 &lt;fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来 &lt;legend&gt; 定义了 &lt;fieldset&gt; 元素的标题 &lt;select&gt; 定义了下拉选项列表 &lt;optgroup&gt; 定义选项组 &lt;option&gt; 定义下拉列表中的选项 &lt;button&gt; 定义一个点击按钮 &lt;datalist&gt; 指定一个预先定义的输入控件选项列表 &lt;keygen&gt; 定义了表单的密钥对生成器字段 &lt;output&gt; 定义一个计算结果 文本域：1234&lt;form&gt;First name: &lt;input type="text" name="firstname"&gt;&lt;br&gt;Last name: &lt;input type="text" name="lastname"&gt;&lt;/form&gt; 密码字段：123&lt;form&gt;Password: &lt;input type="password" name="pwd"&gt;&lt;/form&gt; 单选按钮：1234&lt;form&gt;&lt;input type="radio" name="sex" value="male"&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt; 复选框：1234&lt;form&gt;&lt;input type="checkbox" name="vehicle" value="Bike"&gt;I have a bike&lt;br&gt;&lt;input type="checkbox" name="vehicle" value="Car"&gt;I have a car&lt;/form&gt; 提交按钮：1234&lt;form name="input" action="html_form_action.php" method="get"&gt;Username: &lt;input type="text" name="user"&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; HTML 内联框架iframe 移除边框： 1&lt;iframe src="demo_iframe.htm" frameborder="0"&gt;&lt;/iframe&gt; 使用 iframe 来显示目录链接页面： 12&lt;iframe src="demo_iframe.htm" name="iframe_a"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href="http://www.xxx.com" target="iframe_a"&gt;xxx.com&lt;/a&gt;&lt;/p&gt; HTML 颜色颜色值：HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00），最大值是255（十六进制：#FF）。 颜色名：141个颜色名称是在HTML和CSS颜色规范定义的（17个标准颜色，再加另外124个）。17个标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。 HTML &lt;noscript&gt; 标签&lt;noscript&gt; 标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。&lt;noscript&gt; 元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。 1234&lt;script&gt;document.write("Hello World!")&lt;/script&gt;&lt;noscript&gt;Sorry, your browser does not support JavaScript!&lt;/noscript&gt; HTML 实体在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体。 如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60; 或 &amp;#060; 。使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。比较重要的一点是：实体名称对大小写敏感。 浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &amp;nbsp; 字符实体。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派之网络摄像头配置]]></title>
      <url>%2F2015%2F05%2F24%2Fraspberry-pi-webcam-using-mjpg-streamer-over-internet%2F</url>
      <content type="text"><![CDATA[安装支持库1$ sudo aptitude install libjpeg8-dev imagemagick libv4l-dev cmake 编译mjpg-streamer当前用户是pi，目录是/home/pi/。 12345$ git clone https://github.com/jacksonliam/mjpg-streamer.git$ cd mjpg-streamer/mjpg-streamer-experimental/$ sudo make clean all$ cd ..$ sudo chown -R pi:pi mjpg-streamer-experimental/ 编写启动脚本1$ sudo vi /etc/init.d/webcam 脚本内容修改代码中第15行的DAEMON变量为mjpg-streamer的执行目录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/bin/sh# /etc/init.d/webcam### BEGIN INIT INFO# Provides: webcam# Required-Start: $network# Required-Stop: $network# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: mjpg_streamer for webcam# Description: Streams /dev/video0 to http://IP/?action=stream### END INIT INFODAEMON=/home/pi/mjpg-streamer/mjpg-streamer-experimentalWC_USER=userWC_PASSWORD=passwordWC_PORT=12345f_message()&#123; echo "[+] $1"&#125;# Carry out specific functions when asked to by the systemcase "$1" in start) f_message "Starting mjpg_streamer" $DAEMON/mjpg_streamer -b -i "$DAEMON/input_uvc.so" -o "$DAEMON/output_http.so -w $DAEMON/www -c $WC_USER:$WC_PASSWORD -p $WC_PORT" sleep 2 f_message "mjpg_streamer started" ;; stop) f_message "Stopping mjpg_streamer…" killall mjpg_streamer f_message "mjpg_streamer stopped" ;; restart) f_message "Restarting daemon: mjpg_streamer" killall mjpg_streamer $DAEMON/mjpg_streamer -b -i "$DAEMON/input_uvc.so" -o "$DAEMON/output_http.so -w $DAEMON/www -c $WC_USER:$WC_PASSWORD -p $WC_PORT" sleep 2 f_message "Restarted daemon: mjpg_streamer" ;; status) pid=`ps -A | grep mjpg_streamer | grep -v "grep" | grep -v mjpg_streamer. | awk '&#123;print $1&#125;' | head -n 1` if [ -n "$pid" ]; then f_message "mjpg_streamer is running with pid $&#123;pid&#125;" f_message "mjpg_streamer was started with the following command line" cat /proc/$&#123;pid&#125;/cmdline ; echo "" else f_message "Could not find mjpg_streamer running" fi ;; *) f_message "Usage: $0 &#123;start|stop|status|restart&#125;" exit 1 ;;esacexit 0 默认登录的用户名是user，密码是password，端口是12345（可以在代码中第16，17，18行修改）。 赋予脚本执行权限1$ sudo chmod +x /etc/init.d/webcam 配置脚本开机启动1$ sudo update-rc.d webcam defaults 启动网络摄像头后台程序1$ sudo /etc/init.d/webcam start 查看网络摄像头运行状态1$ sudo /etc/init.d/webcam status 重启网络摄像头后台程序1$ sudo /etc/init.d/webcam restart 停止网络摄像头后台程序1$ sudo /etc/init.d/webcam stop 浏览器中查看网络摄像头访问地址：http://树莓派的IP地址:自定义的端口号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第10章学习笔记]]></title>
      <url>%2F2015%2F05%2F05%2Fbeginning-ios7-development-exploring-the-ios-sdk-10%2F</url>
      <content type="text"><![CDATA[自定义单元1.创建标签： 1234567891011121314- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.label = [[UILabel alloc] initWithFrame:self.contentView.bounds]; self.label.opaque = NO; self.label.backgroundColor = [UIColor colorWithRed:0.8 green:0.9 blue:1.0 alpha:1.0]; self.label.textColor = [UIColor blackColor]; self.label.textAlignment = NSTextAlignmentCenter; self.label.font = [[self class] defaultFont]; [self.contentView addSubview:self.label]; &#125; return self;&#125; 2.重写text属性： 123456789101112131415- (NSString *)text &#123; return self.label.text;&#125;- (void)setText:(NSString *)text &#123; self.label.text = text; CGRect newLabelFrame = self.label.frame; CGRect newContentFrame = self.contentView.frame; CGSize textSize = [[self class] sizeForContentString:text]; newLabelFrame.size = textSize; newContentFrame.size = textSize; self.label.frame = newLabelFrame; self.contentView.frame = newContentFrame;&#125; 3.获取字体尺寸： 123456789101112131415161718192021222324+ (UIFont *)defaultFont &#123; return [UIFont preferredFontForTextStyle:UIFontTextStyleBody];&#125;+ (CGSize)sizeForContentString:(NSString *)string &#123; CGSize maxSize = CGSizeMake(300, 1000); NSStringDrawingOptions opts = NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading; NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; [style setLineBreakMode:NSLineBreakByCharWrapping]; NSDictionary *attributes = @&#123; NSFontAttributeName : [self defaultFont], NSParagraphStyleAttributeName : style &#125;; CGRect rect = [string boundingRectWithSize:maxSize options:opts attributes:attributes context:nil]; return rect.size;&#125; 配置视图控制器1.初始化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.sections = @[ @&#123; @"header" : @"First Witch", @"content" : @"Hey, when will the three of us meet up later?" &#125;, @&#123; @"header" : @"Second Witch", @"content" : @"When everything's straightened out." &#125;, @&#123; @"header" : @"Third Witch", @"content" : @"That'll be just before sunset." &#125;, @&#123; @"header" : @"First Witch", @"content" : @"Where?" &#125;, @&#123; @"header" : @"Second Witch", @"content" : @"The dirt patch." &#125;, @&#123; @"header" : @"Third Witch", @"content" : @"I guess we'll see Mac there." &#125;, ]; [self.collectionView registerClass:[BIDContentCell class] forCellWithReuseIdentifier:@"CONTENT"]; self.collectionView.backgroundColor = [UIColor whiteColor]; UIEdgeInsets contentInset = self.collectionView.contentInset; contentInset.top = 20; [self.collectionView setContentInset:contentInset]; UICollectionViewLayout *layout = self.collectionView.collectionViewLayout; UICollectionViewFlowLayout *flow = (UICollectionViewFlowLayout *)layout; flow.sectionInset = UIEdgeInsetsMake(10, 20, 30, 20); [self.collectionView registerClass:[BIDHeaderCell class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"HEADER"]; flow.headerReferenceSize = CGSizeMake(100, 25);&#125; 2.实现流式布局： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (NSArray *)wordsInSection:(NSInteger)setion &#123; NSString *content = self.sections[setion][@"content"]; NSCharacterSet *space = [NSCharacterSet whitespaceAndNewlineCharacterSet]; NSArray *words = [content componentsSeparatedByCharactersInSet:space]; return words;&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; NSArray *words = [self wordsInSection:section]; return [words count];&#125;- (NSInteger)numberOfSectionsInCollectionView: (UICollectionView *)collectionView &#123; return [self.sections count];&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; NSArray *words = [self wordsInSection:indexPath.section]; BIDContentCell *cell = [self.collectionView dequeueReusableCellWithReuseIdentifier:@"CONTENT" forIndexPath:indexPath]; cell.text = words[indexPath.row]; return cell;&#125;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath &#123; NSArray *words = [self wordsInSection:indexPath.section]; CGSize size = [BIDContentCell sizeForContentString:words[indexPath.row]]; return size;&#125;- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath &#123; if ([kind isEqual:UICollectionElementKindSectionHeader]) &#123; BIDHeaderCell *cell = [self.collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@"HEADER" forIndexPath:indexPath]; cell.text = self.sections[indexPath.row][@"header"]; return cell; &#125; return nil;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第09章学习笔记]]></title>
      <url>%2F2015%2F05%2F04%2Fbeginning-ios7-development-exploring-the-ios-sdk-09%2F</url>
      <content type="text"><![CDATA[Font应用的基础框架1.工厂方法代码示例： 12345678910+ (instancetype)sharedFavoritesList &#123; static BIDFavoritesList *shared = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; shared = [[self alloc] init]; &#125;); return shared;&#125; 2.读取用户偏好设置代码示例： 1234567891011121314- (instancetype)init &#123; self = [super init]; if (self) &#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; NSArray *storedFavorites = [defaults objectForKey:@"favorites"]; if (storedFavorites) &#123; self.favorites = [storedFavorites mutableCopy]; &#125; else &#123; self.favorites = [NSMutableArray array]; &#125; &#125; return self;&#125; 3.保存用户偏好设置代码示例： 123456- (void)moveItemAtIndex:(NSInteger)from toIndex:(NSInteger)to &#123; id item = _favorites[from]; [_favorites removeObjectAtIndex:from]; [_favorites insertObject:item atIndex:to]; [self saveFavorites];&#125; 创建根视图控制器1.获取所有已知字体名字： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; self.familyNames = [[UIFont familyNames] sortedArrayUsingSelector:@selector(compare:)]; UIFont *preferredTableViewFont = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; self.cellPointSize = preferredTableViewFont.pointSize; self.favoritesList = [BIDFavoritesList sharedFavoritesList];&#125; 2.设置分区标题： 12345678- (NSString *)tableView:(UITableView *)tableViewtitleForHeaderInSection:(NSInteger)section &#123; if (section == 0) &#123; return @"All Font Families"; &#125; else &#123; return @"My Favorite Fonts"; &#125;&#125; 3.根据字体大小设置每行高度： 123456789- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (indexPath.section == 0) &#123; UIFont *font = [self fontForDisplayAtIndexPath:indexPath]; return 25 + font.ascender - font.descender; &#125; else &#123; return tableView.rowHeight; &#125;&#125; 创建字体列表视图控制器1.添加编辑按钮： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; UIFont *preferredTableViewFont = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; self.cellPointSize = preferredTableViewFont.pointSize; if (self.showsFavorites) &#123; self.navigationItem.rightBarButtonItem = self.editButtonItem; &#125;&#125; 2.在视图将要出现时，重载数据： 123456- (void)viewWillAppear:(BOOL)animated &#123; if (self.showsFavorites) &#123; self.fontNames = [BIDFavoritesList sharedFavoritesList].favorites; [self.tableView reloadData]; &#125;&#125; 3.使每行数据都能编辑： 12345- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123; // Return NO if you do not want the specified item to be editable. return self.showsFavorites;&#125; 4.删除某行数据： 12345678910111213141516171819- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (!self.showsFavorites) &#123; return; &#125; if (editingStyle == UITableViewCellEditingStyleDelete) &#123; NSString *favorite = self.fontNames[indexPath.row]; [[BIDFavoritesList sharedFavoritesList] removeFavorite:favorite]; self.fontNames = [BIDFavoritesList sharedFavoritesList].favorites; // Delete the row from the data source [tableView deleteRowsAtIndexPaths:@[ indexPath ] withRowAnimation:UITableViewRowAnimationFade]; //&#125; else if (editingStyle == UITableViewCellEditingStyleInsert) &#123; // Create a new instance of the appropriate class, insert it into the array, // and add a new row to the table view &#125;&#125; 5.调整某行数据： 1234567- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath &#123; [[BIDFavoritesList sharedFavoritesList] moveItemAtIndex:fromIndexPath.row toIndex:toIndexPath.row]; self.fontNames = [BIDFavoritesList sharedFavoritesList].favorites;&#125; 6.场景跳转时的数据处理： 12345678910111213141516- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; NSIndexPath *indexPath = [self.tableView indexPathForCell:sender]; UIFont *font = [self fontForDisplayAtIndexPath:indexPath]; [segue.destinationViewController navigationItem].title = font.fontName; if ([segue.identifier isEqualToString:@"ShowFontSizes"]) &#123; BIDFontSizesViewController *sizeVC = segue.destinationViewController; sizeVC.font = font; &#125; else &#123; BIDFontInfoViewController *infoVC = segue.destinationViewController; infoVC.font = font; infoVC.favorite = [[BIDFavoritesList sharedFavoritesList] .favorites containsObject:font.fontName]; &#125;&#125; 创建字体尺寸视图控制器1.字体大小数组初始化： 1234567891011121314151617181920212223- (NSArray *)pointSizes &#123; static NSArray *pointSizes = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; pointSizes = @[ @9, @10, @11, @12, @13, @14, @18, @24, @36, @48, @64, @72, @96, @144 ]; &#125;); return pointSizes;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第08章学习笔记]]></title>
      <url>%2F2015%2F05%2F01%2Fbeginning-ios7-development-exploring-the-ios-sdk-08%2F</url>
      <content type="text"><![CDATA[实现简单表1.控制器头文件声明遵循的协议： 12@interface ViewController : UIViewController &lt;UITableViewDelegate, UITableViewDataSource&gt;@end 2.视图加载完毕后调整表的顶部位置： 1234UITableView *tableView = (id)[self.view viewWithTag:1];UIEdgeInsets contentInsert = tableView.contentInset;contentInsert.top = 20;[tableView setContentInset:contentInsert]; 3.设置表的总行数： 1234- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return [self.dwarves count];&#125; 4.设置表的各行数据（UITableViewCellStyleDefault参数修改表的样式）： 1234567891011121314151617181920212223242526- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *simpleTableIdentifier = @"SimpleTableIdentifier"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:simpleTableIdentifier]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:simpleTableIdentifier]; &#125; UIImage *image = [UIImage imageNamed:@"star"]; cell.imageView.image = image; cell.textLabel.text = self.dwarves[indexPath.row]; cell.textLabel.font = [UIFont boldSystemFontOfSize:50]; if (indexPath.row &lt; 7) &#123; cell.detailTextLabel.text = @"Mr. Disney"; &#125; else &#123; cell.detailTextLabel.text = @"Mr. Tolkien"; &#125; return cell;&#125; 5.设置表的每行缩进： 1234- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return indexPath.row;&#125; 6.设置表的某一行不能被选择： 12345678- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (indexPath.row == 0) &#123; return nil; &#125; else &#123; return indexPath; &#125;&#125; 7.设置表的每行高度： 1234- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 70;&#125; 8.当表的某一行被选中后的操作： 123456789101112131415- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSString *rowValue = self.dwarves[indexPath.row]; NSString *message = [[NSString alloc] initWithFormat:@"You selected %@", rowValue]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Row Selected!" message:message delegate:nil cancelButtonTitle:@"Yes, I Did" otherButtonTitles:nil]; [alert show]; [tableView deselectRowAtIndexPath:indexPath animated:YES];&#125; 代码实现定制表视图单元1.单元格类代码布局： 123456789101112131415161718192021222324252627282930- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; CGRect nameLabelRect = CGRectMake(0, 5, 70, 15); UILabel *nameMarker = [[UILabel alloc] initWithFrame:nameLabelRect]; nameMarker.textAlignment = NSTextAlignmentRight; nameMarker.text = @"Name:"; nameMarker.font = [UIFont boldSystemFontOfSize:12]; [self.contentView addSubview:nameMarker]; CGRect colorLabelRect = CGRectMake(0, 26, 70, 15); UILabel *colorMarker = [[UILabel alloc] initWithFrame:colorLabelRect]; colorMarker.textAlignment = NSTextAlignmentRight; colorMarker.text = @"Color:"; colorMarker.font = [UIFont boldSystemFontOfSize:12]; [self.contentView addSubview:colorMarker]; CGRect nameValueRect = CGRectMake(80, 5, 200, 15); _nameLabel = [[UILabel alloc] initWithFrame:nameValueRect]; [self.contentView addSubview:_nameLabel]; CGRect colorValueRect = CGRectMake(80, 25, 200, 15); _colorLabel = [[UILabel alloc] initWithFrame:colorValueRect]; [self.contentView addSubview:_colorLabel]; &#125; return self;&#125; 2.定义全局复用的单元格标识： 1static NSString *CellTableIdentifier = @"CellTableIdentifier"; 3.视图控制器加载完毕后，注册表单元类： 123UITableView *tableView = (id)[self.view viewWithTag:1];[tableView registerClass:[NameAndColorTableViewCell class] forCellReuseIdentifier:CellTableIdentifier]; 4.设置表的总行数： 1234- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return [self.computers count];&#125; 5.设置表的各行数据： 12345678910111213- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; NameAndColorTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellTableIdentifier forIndexPath:indexPath]; NSDictionary *rowData = self.computers[indexPath.row]; cell.name = rowData[@"Name"]; cell.color = rowData[@"Color"]; return cell;&#125; Nib文件加载实现定制表视图单元1.视图控制器加载完毕后，从Nib文件中注册表单元类： 12345UITableView *tableView = (id)[self.view viewWithTag:1];tableView.rowHeight = 65;UINib *nib = [UINib nibWithNibName:@"BIDNameAndColorCell" bundle:nil];[tableView registerNib:nib forCellReuseIdentifier:CellTableIdentifier]; 实现分组分区1.视图加载完成之后，加载数据： 12345678UITableView *tableView = (id)[self.view viewWithTag:1];[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:SectionTableIdentifier];NSString *path = [[NSBundle mainBundle] pathForResource:@"sortednames" ofType:@"plist"];self.names = [NSDictionary dictionaryWithContentsOfFile:path];self.keys = [[self.names allKeys] sortedArrayUsingSelector:@selector(compare:)]; 2.设置每个分区的数据个数： 123456- (NSInteger)tableView:(UITableView *)tableViewnumberOfRowsInSection:(NSInteger)section &#123; NSString *key = self.keys[section]; NSArray *nameSection = self.names[key]; return [nameSection count];&#125; 3.设置每个分区的标题： 1234- (NSString *)tableView:(UITableView *)tableViewtitleForHeaderInSection:(NSInteger)section &#123; return self.keys[section];&#125; 实现索引分区1.设置索引标题： 123- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView &#123; return self.keys;&#125; 2.处理顶端边缘偏移的问题： 12345if (tableView.style == UITableViewStylePlain) &#123; UIEdgeInsets contentInset = tableView.contentInset; contentInset.top = 20; [tableView setContentInset:contentInset];&#125; 3.处理状态栏被干扰的问题： 1234UIView *barBackground = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 20)];barBackground.backgroundColor = [UIColor colorWithWhite:1.0 alpha:1.0];[self.view addSubview:barBackground]; 实现搜索栏1.控制器头文件声明遵循的协议： 123@interface SectionsViewController : UIViewController &lt;UITableViewDelegate, UITableViewDataSource, UISearchDisplayDelegate&gt;@end 2.添加实例变量保存搜索匹配的名字： 12NSMutableArray *filteredNames;UISearchDisplayController *searchController; 3.搜索栏初始化操作： 1234567filteredNames = [NSMutableArray array];UISearchBar *searchBar = [[UISearchBar alloc] initWithFrame:CGRectMake(0, 0, 320, 44)];tableView.tableHeaderView = searchBar;searchController = [[UISearchDisplayController alloc] initWithSearchBar:searchBar contentsController:self];searchController.delegate = self;searchController.searchResultsDataSource = self; 4.加载搜索结果： 12345- (void)searchDisplayController:(UISearchDisplayController *)controller didLoadSearchResultsTableView:(UITableView *)tableView &#123; [tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:SectionTableIdentifier];&#125; 5.需重新加载搜索结果： 123456789101112131415161718- (BOOL)searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchString:(NSString *)searchString &#123; [filteredNames removeAllObjects]; if (searchString.length &gt; 0) &#123; NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(NSString *name, NSDictionary *b) &#123; NSRange range = [name rangeOfString:searchString options:NSCaseInsensitiveSearch]; return range.location != NSNotFound; &#125;]; for (NSString *key in self.keys) &#123; NSArray *matches = [self.names[key] filteredArrayUsingPredicate:predicate]; [filteredNames addObjectsFromArray:matches]; &#125; &#125; return YES;&#125; 6.设置分区索引的颜色： 123tableView.sectionIndexBackgroundColor = [UIColor blackColor];tableView.sectionIndexTrackingBackgroundColor = [UIColor darkGrayColor];tableView.sectionIndexColor = [UIColor whiteColor];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vim 常用命令总结]]></title>
      <url>%2F2015%2F04%2F30%2Fvim-command-summary%2F</url>
      <content type="text"><![CDATA[光标移动 命令 作用（解释） h,j,k,l h 表示往左，j 表示往下，k 表示往右，l 表示往上 Ctrl+f 上一页 Ctrl+b 下一页 w,e,W,E 跳到单词的后面，小写包括标点 b,B 以单词为单位往前跳动光标，小写包含标点 O 开启新的一行 ^ 一行的开始 $ 一行的结尾 gg 文档的第一行 [N]G 文档的第 N 行或者最后一行 插入模式 命令 作用（解释） i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 o,O 新开一行 Esc 关闭插入模式 编辑 命令 作用（解释） r 在插入模式替换光标所在的一个字符 J 合并下一行到上一行 s 删除光标所在的一个字符, 光标还在当行 S 删除光标所在的一行，光标还在当行，不同于 dd u 撤销上一步操作 Ctrl+r 恢复上一步操作 . 重复最后一个命令 ~ 变换为大写 [N]&gt;&gt; 一行或 N 行往右移动一个 Tab [N]&lt;&lt; 一行或 N 行往左移动一个 Tab 关闭 命令 作用（解释） :w 保存 :wq,:x 保存并关闭 :q 关闭（已保存） :q! 强制关闭 搜索 命令 作用（解释） /pattern 搜索（非插入模式) ?pattern 往后搜索 n 光标到达搜索结果的前一个目标 N 光标到达搜索结果的后一个目标 视觉模式 命令 作用（解释） v 选中一个或多个字符 V 选中一行 剪切和复制 命令 作用（解释） dd 删除一行 dw 删除一个单词 x 删除后一个字符 X 删除前一个字符 D 删除一行最后一个字符 [N]yy 复制一行或者N行 yw 复制一个单词 p 粘贴 窗口操作 命令 作用（解释） :split 水平方向分割出一个窗口 :vsplit 垂直方向分割出一个窗口 :close 关闭窗口 Ctrl+W 切换窗口,h 到左边窗口，j 到下方窗口，k 到上方窗口，l 到右边窗口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第07章学习笔记]]></title>
      <url>%2F2015%2F04%2F29%2Fbeginning-ios7-development-exploring-the-ios-sdk-07%2F</url>
      <content type="text"><![CDATA[实现日期选取器日期数据初始化： 123456- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. NSDate *now = [NSDate date]; [self.datePicker setDate:now animated:YES];&#125; 获取日期选取器的值： 12345678910111213- (IBAction)buttonPressed:(UIButton *)sender &#123; NSDate *selected = [self.datePicker date]; NSString *message = [[NSString alloc] initWithFormat:@"The date and time you selected is: %@", selected]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Date and Time Selected" message:message delegate:nil cancelButtonTitle:@"That's so true!" otherButtonTitles:nil]; [alert show];&#125; 实现单滚轮选取器声明遵循的协议： 1234@interface BIDSingleComponentPickerViewController : UIViewController &lt;UIPickerViewDelegate, UIPickerViewDataSource&gt;@end 实现数据源和委托： 1234567891011121314151617#pragma mark -#pragma mark Picker Data Source Methods- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123; return 1;&#125;- (NSInteger)pickerView:(UIPickerView *)pickerViewnumberOfRowsInComponent:(NSInteger)component &#123; return [self.characterNames count];&#125;#pragma mark Picker Delegate Methods- (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123; return self.characterNames[row];&#125; 获取选取器的值： 12345678910111213- (IBAction)buttonPressed:(UIButton *)sender &#123; NSInteger row = [self.singlePicker selectedRowInComponent:0]; NSString *selected = self.characterNames[row]; NSString *title = [[NSString alloc] initWithFormat:@"You selected %@!", selected]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:@"Thank you for choosing." delegate:nil cancelButtonTitle:@"You're Welcome" otherButtonTitles:nil]; [alert show];&#125; 实现多滚轮选取器实现数据源和委托： 12345678910111213141516171819202122232425#pragma mark -#pragma mark Picker Data Source Methods- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123; return 2;&#125;- (NSInteger)pickerView:(UIPickerView *)pickerViewnumberOfRowsInComponent:(NSInteger)component &#123; if (component == kBreadComponent) &#123; return [self.breadTypes count]; &#125; else &#123; return [self.fillingTypes count]; &#125;&#125;#pragma mark Picker Delegate Methods- (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123; if (component == kBreadComponent) &#123; return self.breadTypes[row]; &#125; else &#123; return self.fillingTypes[row]; &#125;&#125; 获取选取器的值： 12345678910111213- (IBAction)buttonPressed:(UIButton *)sender &#123; NSInteger fillingRow = [self.doublePicker selectedRowInComponent:kFillingComponent]; NSInteger breadRow = [self.doublePicker selectedRowInComponent:kBreadComponent]; NSString *filling = self.fillingTypes[fillingRow]; NSString *bread = self.breadTypes[breadRow]; NSString *message = [[NSString alloc] initWithFormat:@"Your %@ on %@ bread will be right up.", filling, bread]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Thank you for your order" message:message delegate:nil cancelButtonTitle:@"Great!" otherButtonTitles:nil]; [alert show];&#125; 实现依赖型多滚轮选取器获取包数据： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. NSBundle *bundle = [NSBundle mainBundle]; NSURL *plistURL = [bundle URLForResource:@"statedictionary" withExtension:@"plist"]; self.stateZips = [NSDictionary dictionaryWithContentsOfURL:plistURL]; NSArray *allStates = [self.stateZips allKeys]; NSArray *sortedStates = [allStates sortedArrayUsingSelector:@selector(compare:)]; self.states = sortedStates; NSString *selectedState = self.states[0]; self.zips = self.stateZips[selectedState];&#125; 实现数据源和委托： 123456789101112131415161718192021222324252627282930313233343536#pragma mark -#pragma mark Picker Data Source Methods- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123; return 2;&#125;- (NSInteger)pickerView:(UIPickerView *)pickerViewnumberOfRowsInComponent:(NSInteger)component &#123; if (component == kStateComponent) &#123; return [self.states count]; &#125; else &#123; return [self.zips count]; &#125;&#125;#pragma mark Picker Delegate Methods- (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123; if (component == kStateComponent) &#123; return self.states[row]; &#125; else &#123; return self.zips[row]; &#125;&#125;- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component &#123; if (component == kStateComponent) &#123; NSString *selectedState = self.states[row]; self.zips = self.stateZips[selectedState]; [self.dependentPicker reloadComponent:kZipComponent]; [self.dependentPicker selectRow:0 inComponent:kZipComponent animated:YES]; &#125;&#125; 获取选取器的值： 1234567891011121314151617181920- (IBAction)buttonPressed:(UIButton *)sender &#123; NSInteger stateRow = [self.dependentPicker selectedRowInComponent:kStateComponent]; NSInteger zipRow = [self.dependentPicker selectedRowInComponent:kZipComponent]; NSString *state = self.states[stateRow]; NSString *zip = self.zips[zipRow]; NSString *title = [[NSString alloc] initWithFormat:@"You selected zip code %@", zip]; NSString *message = [[NSString alloc] initWithFormat:@"%@ is in %@", zip, state]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:message delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil]; [alert show];&#125; 设置每个滚轮组件的宽度： 12345678- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component &#123; if (component == kZipComponent) &#123; return 90; &#125; else &#123; return 200; &#125;&#125; 实现自定义视图选取器实现数据源和委托： 1234567891011121314151617181920#pragma mark -#pragma mark Picker Data Source Methods- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123; return 5;&#125;- (NSInteger)pickerView:(UIPickerView *)pickerViewnumberOfRowsInComponent:(NSInteger)component &#123; return [self.images count];&#125;#pragma mark Picker Delegate Methods- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123; UIImage *image = self.images[row]; UIImageView *imageView = [[UIImageView alloc] initWithImage:image]; return imageView;&#125; 获取选取器的值： 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (IBAction)spin:(UIButton *)sender &#123; BOOL win = NO; int numInRow = 1; int lastVal = -1; for (int i = 0; i &lt; 5; i++) &#123; int newValue = random() % [self.images count]; if (newValue == lastVal) &#123; numInRow++; &#125; else &#123; numInRow = 1; &#125; lastVal = newValue; [self.picker selectRow:newValue inComponent:i animated:YES]; [self.picker reloadComponent:i]; if (numInRow &gt;= 3) &#123; win = YES; &#125; &#125; if (crunchSoundID == 0) &#123; NSString *path = [[NSBundle mainBundle] pathForResource:@"crunch" ofType:@"wav"]; NSURL *soundURL = [NSURL fileURLWithPath:path]; AudioServicesCreateSystemSoundID((__bridge CFURLRef)soundURL, &amp;crunchSoundID); &#125; AudioServicesPlaySystemSound(crunchSoundID); if (win) &#123; [self performSelector:@selector(playWinSound) withObject:nil afterDelay:.5]; &#125; else &#123; [self performSelector:@selector(showButton) withObject:nil afterDelay:.5]; &#125; self.button.hidden = YES; self.winLabel.text = @"";&#125; 设置每个滚轮组件内容的高度： 1234- (CGFloat)pickerView:(UIPickerView *)pickerViewrowHeightForComponent:(NSInteger)component &#123; return 70;&#125; 播放音乐文件： 123456789101112- (void)playWinSound &#123; if (winSoundID == 0) &#123; NSURL *soundURL = [[NSBundle mainBundle] URLForResource:@"win" withExtension:@"wav"]; AudioServicesCreateSystemSoundID((__bridge CFURLRef)soundURL, &amp;winSoundID); &#125; AudioServicesPlaySystemSound(winSoundID); self.winLabel.text = @"WINNING!"; [self performSelector:@selector(showButton) withObject:nil afterDelay:1.5];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第06章学习笔记]]></title>
      <url>%2F2015%2F04%2F29%2Fbeginning-ios7-development-exploring-the-ios-sdk-06%2F</url>
      <content type="text"><![CDATA[延迟加载处理代码示例： 123456- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.blueViewController = [self.storyboard instantiateViewControllerWithIdentifier:@"Blue"]; [self.view insertSubview:self.blueViewController.view atIndex:0];&#125; 内存不足处理代码示例： 123456789- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. if (!self.blueViewController.view.superview) &#123; self.blueViewController = nil; &#125; else &#123; self.yellowViewController = nil; &#125;&#125; 转换过程的动画效果代码示例： 123456789101112131415161718192021222324252627- (IBAction)switchViews:(id)sender &#123; [UIView beginAnimations:@"View Flip" context:NULL]; [UIView setAnimationDuration:0.4]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; if (!self.yellowViewController.view.superview) &#123; if (!self.yellowViewController) &#123; self.yellowViewController = [self.storyboard instantiateViewControllerWithIdentifier:@"Yellow"]; &#125; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.view cache:YES]; [self.blueViewController.view removeFromSuperview]; [self.view insertSubview:self.yellowViewController.view atIndex:0]; &#125; else &#123; if (!self.blueViewController) &#123; self.blueViewController = [self.storyboard instantiateViewControllerWithIdentifier:@"Blue"]; &#125; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.view cache:YES]; [self.yellowViewController.view removeFromSuperview]; [self.view insertSubview:self.blueViewController.view atIndex:0]; &#125; [UIView commitAnimations];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第05章学习笔记]]></title>
      <url>%2F2015%2F04%2F28%2Fbeginning-ios7-development-exploring-the-ios-sdk-05%2F</url>
      <content type="text"><![CDATA[单个控制器的旋转支持代码示例： 123- (NSUInteger)supportedInterfaceOrientations &#123; return (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight);&#125; 代码调整界面布局在界面构造器中，将Use Autolayout复选框取消选中。 旋转时移动按钮代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration &#123; [self doLayoutForOrientation:toInterfaceOrientation];&#125;- (void)doLayoutForOrientation:(UIInterfaceOrientation)orientation &#123; if (UIInterfaceOrientationIsPortrait(orientation)) &#123; [self layoutPortrait]; &#125; else &#123; [self layoutLandscape]; &#125;&#125;static const CGFloat buttonHeight = 40;static const CGFloat buttonWidth = 120;static const CGFloat spacing = 20;- (void)layoutPortrait &#123; CGRect b = self.view.bounds; CGFloat contentWidth = CGRectGetWidth(b) - (2 * spacing); CGFloat contentHeight = CGRectGetHeight(b) - (4 * spacing) - (2 * buttonHeight); self.contentView.frame = CGRectMake(spacing, spacing, contentWidth, contentHeight); CGFloat buttonRow1y = contentHeight + (2 * spacing); CGFloat buttonRow2y = buttonRow1y + buttonHeight + spacing; CGFloat buttonCol1x = spacing; CGFloat buttonCol2x = CGRectGetWidth(b) - buttonWidth - spacing; self.actionButton1.frame = CGRectMake(buttonCol1x, buttonRow1y, buttonWidth, buttonHeight); self.actionButton2.frame = CGRectMake(buttonCol2x, buttonRow1y, buttonWidth, buttonHeight); self.actionButton3.frame = CGRectMake(buttonCol1x, buttonRow2y, buttonWidth, buttonHeight); self.actionButton4.frame = CGRectMake(buttonCol2x, buttonRow2y, buttonWidth, buttonHeight);&#125;- (void)layoutLandscape &#123; CGRect b = self.view.bounds; CGFloat contentWidth = CGRectGetWidth(b) - buttonWidth - (3 * spacing); CGFloat contentHeight = CGRectGetHeight(b) - (2 * spacing); self.contentView.frame = CGRectMake(spacing, spacing, contentWidth, contentHeight); CGFloat buttonX = CGRectGetWidth(b) - buttonWidth - spacing; CGFloat buttonRow1y = spacing; CGFloat buttonRow4y = CGRectGetHeight(b) - buttonHeight - spacing; CGFloat buttonRow2y = buttonRow1y + floor((buttonRow4y - buttonRow1y) * 0.333); CGFloat buttonRow3y = buttonRow1y + floor((buttonRow4y - buttonRow1y) * 0.667); self.actionButton1.frame = CGRectMake(buttonX, buttonRow1y, buttonWidth, buttonHeight); self.actionButton2.frame = CGRectMake(buttonX, buttonRow2y, buttonWidth, buttonHeight); self.actionButton3.frame = CGRectMake(buttonX, buttonRow3y, buttonWidth, buttonHeight); self.actionButton4.frame = CGRectMake(buttonX, buttonRow4y, buttonWidth, buttonHeight);&#125; 获取视图加载完后的屏幕方向代码示例： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIApplication *app = [UIApplication sharedApplication]; UIInterfaceOrientation currentOrientation = app.statusBarOrientation; [self doLayoutForOrientation:currentOrientation];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精通iOS开发》第04章学习笔记]]></title>
      <url>%2F2015%2F04%2F28%2Fbeginning-ios7-development-exploring-the-ios-sdk-04%2F</url>
      <content type="text"><![CDATA[调整图像视图的大小按键： COMMAND + = 或者菜单选择 Editor ➤ Size to Fit Content 输入完成后关闭键盘添加以下函数，并关联Did End On Exit事件： 123- (IBAction)textFieldDoneEditing:(UITextField *)sender &#123; [sender resignFirstResponder];&#125; 通过触摸背景关闭键盘将view所指向的UIView对象所属类改成UIControl，并添加以下函数关联Touch Down事件： 1234- (IBAction)backgroundTap:(id)sender &#123; [self.nameField resignFirstResponder]; [self.numberField resignFirstResponder];&#125; 滑动条代码示例： 1234- (IBAction)sliderChanged:(UISlider *)sender &#123; int progress = lround(sender.value); self.sliderLabel.text = [NSString stringWithFormat:@"%d", progress];&#125; 开关控件代码示例： 12345- (IBAction)switchChanged:(UISwitch *)sender &#123; BOOL setting = sender.isOn; [self.leftSwitch setOn:setting animated:YES]; [self.rightSwitch setOn:setting animated:YES];&#125; 分段控件代码示例： 1234567891011- (IBAction)toggleControls:(UISegmentedControl *)sender &#123; if (sender.selectedSegmentIndex == 0) &#123; self.leftSwitch.hidden = NO; self.rightSwitch.hidden = NO; self.doSomethingButton.hidden = YES; &#125; else &#123; self.leftSwitch.hidden = YES; self.rightSwitch.hidden = YES; self.doSomethingButton.hidden = NO; &#125;&#125; 操作表单需要遵从UIActionSheetDelegate协议，代码示例： 1234- (IBAction)buttonPressed:(UIButton *)sender &#123; UIActionSheet *actionSheet = [[UIActionSheet alloc] initWithTitle:@"Are you sure?" delegate:self cancelButtonTitle:@"No Way!" destructiveButtonTitle:@"Yes, I'm Sure!" otherButtonTitles:nil]; [actionSheet showInView:self.view];&#125; 警告视图需要遵从UIAlertViewDelegate协议，代码示例： 1234567891011121314- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex &#123; if (buttonIndex != [actionSheet cancelButtonIndex]) &#123; NSString *msg = nil; if ([self.nameField.text length] &gt; 0) &#123; msg = [NSString stringWithFormat:@"You can breathe easy, %@, everything went OK.", self.nameField.text]; &#125; else &#123; msg = @"You can breathe easy, eveything went OK."; &#125; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Sonmething was done" message:msg delegate:nil cancelButtonTitle:@"Phew!" otherButtonTitles:nil]; [alert show]; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何同时使用多个公秘钥]]></title>
      <url>%2F2015%2F04%2F26%2Fhow-to-use-multiple-public-secret-key%2F</url>
      <content type="text"><![CDATA[生成新的 SSH 秘钥（记得输入 passphrase 口令）： 123$ ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/github_rsa$ ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/gitcafe_rsa$ ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/oschina_rsa 新建或修改~/.ssh/config文件中的内容： 1234567891011Host github.com IdentityFile ~/.ssh/github_rsa User gitHost gitcafe.com IdentityFile ~/.ssh/gitcafe_rsa User gitHost git.oschina.net IdentityFile ~/.ssh/oschina_rsa User git 测试配置文件是否正常工作： 123$ ssh -T git@github.com$ ssh -T git@gitcafe.com$ ssh -T git@git.oschina.net 测试出异常的时候，可以添加-v参数查看具体原因： 123$ ssh -T -v git@github.com$ ssh -T -v git@gitcafe.com$ ssh -T -v git@git.oschina.net 出现类似git@git.oschina.net&#39;s password:的提示，怎么输密码都不对情况，多数是~/.ssh/config文件中域名部分填错了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之类和结构体学习笔记]]></title>
      <url>%2F2015%2F04%2F26%2Fthe-swift-programming-language-09-classes-and-structures%2F</url>
      <content type="text"><![CDATA[类和结构体的对比定义语法： 12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体的实例： 12let someResolution = Resolution()let someVideoMode = VideoMode() 属性访问： 123someVideoMode.resolution.width = 1280println("The width of someVideoMode is now \(someVideoMode.resolution.width)")// prints "The width of someVideoMode is now 1280" 结构体类型的成员构造器（类实例没有）： 1let vga = Resolution(width: 640, height: 480) 结构体和枚举是值类型结构体： 12345678910let hd = Resolution(width: 1920, height: 1080)var cinema = hdcinema.width = 2048println("cinema is now \(cinema.width) pixels wide")// prints "cinema is now 2048 pixels wide"println("hd is still \(hd.width) pixels wide")// prints "hd is still 1920 pixels wide" 枚举： 123456789101112enum CompassPoint &#123; case North, South, East, West&#125;var currentDirection = CompassPoint.Westlet rememberedDirection = currentDirectioncurrentDirection = .Eastif rememberedDirection == .West &#123; println("The remembered direction is still .West")&#125;// prints "The remembered direction is still .West" 类是引用类型1234567891011let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = "1080i"tenEighty.frameRate = 25.0let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0println("The frameRate property of tenEighty is now \(tenEighty.frameRate)")// prints "The frameRate property of tenEighty is now 30.0" 标识恒等运算符（===和!==）： 1234if tenEighty === alsoTenEighty &#123; println("tenEighty and alsoTenEighty refer to the same VideoMode instance.")&#125;// prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之枚举学习笔记]]></title>
      <url>%2F2015%2F04%2F25%2Fthe-swift-programming-language-08-enumerations%2F</url>
      <content type="text"><![CDATA[枚举语法定义： 123456enum CompassPoint &#123; case North case South case East case West&#125; 单行定义： 123enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125; 声明： 12var directionToHead = CompassPoint.WestdirectionToHead = .East 使用switch语句匹配枚举值123456789101112directionToHead = .Southswitch directionToHead &#123;case .North: println("Lots of planets have a north")case .South: println("Watch out for penguins")case .East: println("Where the sun rises")case .West: println("Where the skies are blue")&#125;// prints "Watch out for penguins" 关联值123456789101112131415enum Barcode &#123; case UPCA(Int, Int, Int, Int) case QRCode(String)&#125;var productBarcode = Barcode.UPCA(8, 85909, 51226, 3)productBarcode = .QRCode("ABCDEFGHIJKLMNOP")switch productBarcode &#123;case let .UPCA(numberSystem, manufacturer, product, check): println("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")case let .QRCode(productCode): println("QR code: \(productCode).")&#125;// prints "QR code: ABCDEFGHIJKLMNOP." 原始值123456enum Planet: Int &#123; case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125;let earthsOrder = Planet.Earth.rawValue// earthsOrder is 3 从原始值初始化： 12let possiblePlanet = Planet(rawValue: 7)// possiblePlanet is of type Planet? and equals Planet.Uranus]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之闭包学习笔记]]></title>
      <url>%2F2015%2F04%2F24%2Fthe-swift-programming-language-07-closures%2F</url>
      <content type="text"><![CDATA[闭包表达式闭包表达式语法： 123456789101112let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]func backwards(s1: String, s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversed = sorted(names, backwards)// reversed is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]reversed = sorted(names, &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 根据上下文推断类型： 1reversed = sorted(names, &#123; s1, s2 in return s1 &gt; s2 &#125; ) 单行表达式闭包的隐式返回： 1reversed = sorted(names, &#123; s1, s2 in s1 &gt; s2 &#125; ) 简写参数名： 1reversed = sorted(names, &#123; $0 &gt; $1 &#125; ) 运算符函数： 1reversed = sorted(names, &gt;) 尾随闭包123456789101112131415func someFunctionThatTakesAClosure(closure: () -&gt; ()) &#123; // function body goes here&#125;// here's how you call this function without using a trailing closure:someFunctionThatTakesAClosure(&#123; // closure's body goes here&#125;)// here's how you call this function with a trailing closure instead:someFunctionThatTakesAClosure() &#123; // trailing closure's body goes here&#125; 值捕获12345678func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125; 闭包是引用类型12345678910111213let incrementByTen = makeIncrementer(forIncrement: 10)incrementByTen()// returns a value of 10incrementByTen()// returns a value of 20incrementByTen()// returns a value of 30incrementByTen()// returns a value of 40let alsoIncrementByTen = incrementByTenalsoIncrementByTen()// returns a value of 50]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之函数学习笔记]]></title>
      <url>%2F2015%2F04%2F23%2Fthe-swift-programming-language-06-functions%2F</url>
      <content type="text"><![CDATA[函数的定义与调用函数定义： 1234func sayHello(personName: String) -&gt; String &#123; let greeting = "Hello, " + personName + "!" return greeting&#125; 函数调用： 1234println(sayHello("Anna"))// prints "Hello, Anna!"println(sayHello("Brian"))// prints "Hello, Brian!" 函数参数和返回值多个输入形参： 12345func halfOpenRangeLength(start: Int, end: Int) -&gt; Int &#123; return end - start&#125;println(halfOpenRangeLength(1, 10))// prints "9" 无参数函数： 12345func sayHelloWorld() -&gt; String &#123; return "hello, world"&#125;println(sayHelloWorld())// prints "hello, world" 无返回值的函数： 12345func sayGoodbye(personName: String) &#123; println("Goodbye, \(personName)!")&#125;sayGoodbye("Dave")// prints "Goodbye, Dave!" 多返回值函数： 12345678910111213141516func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let bounds = minMax([8, -6, 2, 109, 3, 71])println("min is \(bounds.min) and max is \(bounds.max)")// prints "min is -6 and max is 109" 返回类型之可选元组： 123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;if let bounds = minMax([8, -6, 2, 109, 3, 71]) &#123; println("min is \(bounds.min) and max is \(bounds.max)")&#125;// prints "min is -6 and max is 109" 函数参数名称外部参数名称： 1234567func join(string s1: String, toString s2: String, withJoiner joiner: String) -&gt; String &#123; return s1 + joiner + s2&#125;join(string: "hello", toString: "world", withJoiner: ", ")// returns "hello, world" 简写外部参数名称： 1234567891011func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool &#123; for character in string &#123; if character == characterToFind &#123; return true &#125; &#125; return false&#125;let containsAVee = containsCharacter(string: "aardvark", characterToFind: "v")// containsAVee equals true, because "aardvark" contains a "v" 参数默认值： 12345678910func join(string s1: String, toString s2: String, withJoiner joiner: String = " ") -&gt; String &#123; return s1 + joiner + s2&#125;join(string: "hello", toString: "world", withJoiner: "-")// returns "hello-world"join(string: "hello", toString: "world")// returns "hello world" 带默认值的外部参数名（自动提供外部参数名）： 123456func join(s1: String, s2: String, joiner: String = " ") -&gt; String &#123; return s1 + joiner + s2&#125;join("hello", "world", joiner: "-")// returns "hello-world" 可变参数： 1234567891011func arithmeticMean(numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3.0, which is the arithmetic mean of these five numbersarithmeticMean(3, 8.25, 18.75)// returns 10.0, which is the arithmetic mean of these three numbers 常量形参和变量形参（var定义变量参数）： 12345678910111213141516func alignRight(var string: String, count: Int, pad: Character) -&gt; String &#123; let amountToPad = count - count(string) if amountToPad &lt; 1 &#123; return string &#125; let padString = String(pad) for _ in 1...amountToPad &#123; string = padString + string &#125; return string&#125;let originalString = "hello"let paddedString = alignRight(originalString, 10, "-")// paddedString is equal to "-----hello"// originalString is still equal to "hello" 输入输出形参： 1234567891011func swapTwoInts(inout a: Int, inout b: Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")// prints "someInt is now 107, and anotherInt is now 3" 函数类型使用函数类型： 1234567891011121314func addTwoInts(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(a: Int, b: Int) -&gt; Int &#123; return a * b&#125;var mathFunction: (Int, Int) -&gt; Int = addTwoIntsprintln("Result: \(mathFunction(2, 3))")// prints "Result: 5"mathFunction = multiplyTwoIntsprintln("Result: \(mathFunction(2, 3))")// prints "Result: 6" 函数类型作为函数形参： 12345func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) &#123; println("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5)// prints "Result: 8" 函数类型作为函数返回值： 1234567891011121314func stepForward(input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(input: Int) -&gt; Int &#123; return input - 1&#125;func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int &#123; return backwards ? stepBackward : stepForward&#125;var currentValue = 3let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)// moveNearerToZero now refers to the stepBackward() function 嵌套函数123456789101112131415161718func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backwards ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 &#123; println("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;println("zero!")// -4...// -3...// -2...// -1...// zero!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之控制流学习笔记]]></title>
      <url>%2F2015%2F04%2F22%2Fthe-swift-programming-language-05-control-flow%2F</url>
      <content type="text"><![CDATA[for循环for-in（数组，集合，字典，字符串类似）： 12345678for index in 1...5 &#123; println("\(index) times 5 is \(index * 5)")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 忽略对值的访问： 12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;println("\(base) to the power of \(power) is \(answer)")// prints "3 to the power of 10 is 59049" for循环： 123456for var index = 0; index &lt; 3; ++index &#123; println("index is \(index)")&#125;// index is 0// index is 1// index is 2 while循环while循环： 12345678910111213var square = 0var diceRoll = 0while square &lt; finalSquare &#123; // roll the dice if ++diceRoll == 7 &#123; diceRoll = 1 &#125; // move by the rolled amount square += diceRoll if square &lt; board.count &#123; // if we're still on the board, move up or down for a snake or a ladder square += board[square] &#125;&#125;println("Game over!") do-while循环： 12345678910111213141516let finalSquare = 25var board = [Int](count: finalSquare + 1, repeatedValue: 0)board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0do &#123; // move up or down for a snake or ladder square += board[square] // roll the dice if ++diceRoll == 7 &#123; diceRoll = 1 &#125; // move by the rolled amount square += diceRoll&#125; while square &lt; finalSquareprintln("Game over!") 条件语句if语句： 123456789temperatureInFahrenheit = 90if temperatureInFahrenheit &lt;= 32 &#123; println("It's very cold. Consider wearing a scarf.")&#125; else if temperatureInFahrenheit &gt;= 86 &#123; println("It's really warm. Don't forget to wear sunscreen.")&#125; else &#123; println("It's not that cold. Wear a t-shirt.")&#125;// prints "It's really warm. Don't forget to wear sunscreen." switch语句： 1234567891011let someCharacter: Character = "e"switch someCharacter &#123;case "a", "e", "i", "o", "u": println("\(someCharacter) is a vowel")case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m","n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z": println("\(someCharacter) is a consonant")default: println("\(someCharacter) is not a vowel or a consonant")&#125;// prints "e is a vowel" 范围匹配： 123456789101112131415161718192021let count = 3_000_000_000_000let countedThings = "stars in the Milky Way"var naturalCount: Stringswitch count &#123;case 0: naturalCount = "no"case 1...3: naturalCount = "a few"case 4...9: naturalCount = "several"case 10...99: naturalCount = "tens of"case 100...999: naturalCount = "hundreds of"case 1000...999_999: naturalCount = "thousands of"default: naturalCount = "millions and millions of"&#125;println("There are \(naturalCount) \(countedThings).")// prints "There are millions and millions of stars in the Milky Way." 元组： 1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): println("(0, 0) is at the origin")case (_, 0): println("(\(somePoint.0), 0) is on the x-axis")case (0, _): println("(0, \(somePoint.1)) is on the y-axis")case (-2...2, -2...2): println("(\(somePoint.0), \(somePoint.1)) is inside the box")default: println("(\(somePoint.0), \(somePoint.1)) is outside of the box")&#125;// prints "(1, 1) is inside the box" 值绑定： 123456789let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): println("on the x-axis with an x value of \(x)")case (0, let y): println("on the y-axis with a y value of \(y)")case let (x, y): println("somewhere else at (\(x), \(y))")&#125; where语句： 12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: println("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: println("(\(x), \(y)) is on the line x == -y")case let (x, y): println("(\(x), \(y)) is just some arbitrary point")&#125;// prints "(1, -1) is on the line x == -y" 控制转移语句continue语句： 123456789101112let puzzleInput = "great minds think alike"var puzzleOutput = ""for character in puzzleInput &#123; switch character &#123; case "a", "e", "i", "o", "u", " ": continue default: puzzleOutput.append(character) &#125;&#125;println(puzzleOutput)// prints "grtmndsthnklk" break语句： 1234567891011121314151617181920let numberSymbol: Character = "三" // Simplified Chinese for the number 3var possibleIntegerValue: Int?switch numberSymbol &#123;case "1", "١", "一", "๑": possibleIntegerValue = 1case "2", "٢", "二", "๒": possibleIntegerValue = 2case "3", "٣", "三", "๓": possibleIntegerValue = 3case "4", "٤", "四", "๔": possibleIntegerValue = 4default: break&#125;if let integerValue = possibleIntegerValue &#123; println("The integer value of \(numberSymbol) is \(integerValue).")&#125; else &#123; println("An integer value could not be found for \(numberSymbol).")&#125;// prints "The integer value of 三 is 3." fallthrough语句： 1234567891011let integerToDescribe = 5var description = "The number \(integerToDescribe) is"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125;println(description)// prints "The number 5 is a prime number, and also an integer." 带标签的语句： 1234567891011121314151617181920212223let finalSquare = 25var board = [Int](count: finalSquare + 1, repeatedValue: 0)board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0gameLoop: while square != finalSquare &#123; if ++diceRoll == 7 &#123; diceRoll = 1 &#125; switch square + diceRoll &#123; case finalSquare: // diceRoll will move us to the final square, so the game is over break gameLoop case let newSquare where newSquare &gt; finalSquare: // diceRoll will move us beyond the final square, so roll again continue gameLoop default: // this is a valid move, so find out its effect square += diceRoll square += board[square] &#125;&#125;println("Game over!")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之集合类型学习笔记]]></title>
      <url>%2F2015%2F04%2F21%2Fthe-swift-programming-language-04-collection-types%2F</url>
      <content type="text"><![CDATA[数组创建空的数组： 123var someInts = [Int]()println("someInts is of type [Int] with \(someInts.count) items.")// prints "someInts is of type [Int] with 0 items." 添加数组数据项： 1234someInts.append(3)// someInts now contains 1 value of type IntsomeInts = []// someInts is now an empty array, but is still of type [Int] 创建重复数据项的数组： 12var threeDoubles = [Double](count: 3, repeatedValue: 0.0)// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0] 数组相加： 12345var anotherThreeDoubles = [Double](count: 3, repeatedValue: 2.5)// anotherThreeDoubles is inferred as [Double], and equals [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 数组字面量12var shoppingList: [String] = ["Eggs", "Milk"]// shoppingList has been initialized with two initial items 读取和修改数组数组数据项个数： 12println("The shopping list contains \(shoppingList.count) items.")// prints "The shopping list contains 2 items." 判断数组是否为空： 123456if shoppingList.isEmpty &#123; println("The shopping list is empty.")&#125; else &#123; println("The shopping list is not empty.")&#125;// prints "The shopping list is not empty." 数组后面添加新的数据项： 12shoppingList.append("Flour")// shoppingList now contains 3 items, and someone is making pancakes 加法赋值运算符添加数据项： 1234shoppingList += ["Baking Powder"]// shoppingList now contains 4 itemsshoppingList += ["Chocolate Spread", "Cheese", "Butter"]// shoppingList now contains 7 items 下标读取数组中的数据项： 12var firstItem = shoppingList[0]// firstItem is equal to "Eggs" 下标修改数组中的数据项： 12shoppingList[0] = "Six eggs"// the first item in the list is now equal to "Six eggs" rather than "Eggs" 下标修改数组中的一系列数据项： 12shoppingList[4...6] = ["Bananas", "Apples"]// shoppingList now contains 6 items 某个具体索引值之前添加数据项： 123shoppingList.insert("Maple Syrup", atIndex: 0)// shoppingList now contains 7 items// "Maple Syrup" is now the first item in the list 删除某个特定索引值的数据项，并返回这个数据项： 1234let mapleSyrup = shoppingList.removeAtIndex(0)// the item that was at index 0 has just been removed// shoppingList now contains 6 items, and no Maple Syrup// the mapleSyrup constant is now equal to the removed "Maple Syrup" string 删除最后一个数据项： 1234let apples = shoppingList.removeLast()// the last item in the array has just been removed// shoppingList now contains 5 items, and no apples// the apples constant is now equal to the removed "Apples" string 遍历数组12345678for (index, value) in enumerate(shoppingList) &#123; println("Item \(index + 1): \(value)")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 集合创建空的集合： 123var letters = Set&lt;Character&gt;()println("letters is of type Set&lt;Character&gt; with \(letters.count) items.")// prints "letters is of type Set&lt;Character&gt; with 0 items." 插入集合数据项： 1234letters.insert("a")// letters now contains 1 value of type Characterletters = []// letters is now an empty set, but is still of type Set&lt;Character&gt; 集合字面量12var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"]// favoriteGenres has been initialized with three initial items 读取和修改集合集合元素个数： 12println("I have \(favoriteGenres.count) favorite music genres.")// prints ""I have 3 favorite music genres."" 判断集合是否为空： 123456if favoriteGenres.isEmpty &#123; println("As far as music goes, I'm not picky.")&#125; else &#123; println("I have particular music preferences.")&#125;// prints "I have particular music preferences." 向集合中添加新的数据项： 12favoriteGenres.insert("Jazz")// favoriteGenres now contains 4 items 删除某个数据项，并返回这个数据项： 123456if let removedGenre = favoriteGenres.remove("Rock") &#123; println("\(removedValue)? I'm over it.")&#125; else &#123; println("I never much cared for that.")&#125;// prints "Rock? I'm over it." 判断集合是否包含某个数据项： 123456if favoriteGenres.contains("Funk") &#123; println("I get up on the good foot.")&#125; else &#123; println("It's too funky in here.")&#125;// prints "It's too funky in here." 遍历集合使用for-in循环遍历集合： 123456for genre in favoriteGenres &#123; println("\(value)")&#125;// Classical// Jazz// Hip hop 集合排序： 123456for genre in sorted(favoriteGenres) &#123; println("\(genre)")&#125;// prints "Classical"// prints "Hip hop"// prints "Jazz" 字典创建空的字典： 12var namesOfIntegers = [Int: String]()// namesOfIntegers is an empty [Int: String] dictionary 添加字典数据项： 1234namesOfIntegers[16] = "sixteen"// namesOfIntegers now contains 1 key-value pairnamesOfIntegers = [:]// namesOfIntegers is once again an empty dictionary of type [Int: String] 字典字面量1var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"] 读取和修改字典字典数据项个数： 12println("The airports dictionary contains \(airports.count) items.")// prints "The airports dictionary contains 2 items." 判断字典是否为空： 123456if airports.isEmpty &#123; println("The airports dictionary is empty.")&#125; else &#123; println("The airports dictionary is not empty.")&#125;// prints "The airports dictionary is not empty." 字典后面添加新的数据项： 12airports["LHR"] = "London"// the airports dictionary now contains 3 items 下标修改字典中的数据项： 12airports["LHR"] = "London Heathrow"// the value for "LHR" has been changed to "London Heathrow" updateValue(_:forKey:) 方式修改字典中的数据项： 1234if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") &#123; println("The old value for DUB was \(oldValue).")&#125;// prints "The old value for DUB was Dublin." 下标判断字典中是否存在某个数据项： 123456if let airportName = airports["DUB"] &#123; println("The name of the airport is \(airportName).")&#125; else &#123; println("That airport is not in the airports dictionary.")&#125;// prints "The name of the airport is Dublin Airport." 通过下标删除字典中的某个数据项： 1234airports["APL"] = "Apple International"// "Apple International" is not the real airport for APL, so delete itairports["APL"] = nil// APL has now been removed from the dictionary removeValueForKey(_:) 方式删除字典中的数据项： 123456if let removedValue = airports.removeValueForKey("DUB") &#123; println("The removed airport's name is \(removedValue).")&#125; else &#123; println("The airports dictionary does not contain a value for DUB.")&#125;// prints "The removed airport's name is Dublin Airport." 遍历字典键值对同时遍历： 12345678for (index, value) in enumerate(shoppingList) &#123; println("Item \(index + 1): \(value)")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 遍历字典的keys或values： 1234567891011for airportCode in airports.keys &#123; println("Airport code: \(airportCode)")&#125;// Airport code: YYZ// Airport code: LHRfor airportName in airports.values &#123; println("Airport name: \(airportName)")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow 返回字典的keys或values数组： 12345let airportCodes = [String](airports.keys)// airportCodes is ["YYZ", "LHR"]let airportNames = [String](airports.values)// airportNames is ["Toronto Pearson", "London Heathrow"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之字符串与字符学习笔记]]></title>
      <url>%2F2015%2F04%2F20%2Fthe-swift-programming-language-03-strings-and-characters%2F</url>
      <content type="text"><![CDATA[字符串字面量1let someString = "Some string literal value" 初始化空字符串123var emptyString = "" // empty string literalvar anotherEmptyString = String() // initializer syntax// these two strings are both empty, and are equivalent to each other 判断字符串是否为空： 1234if emptyString.isEmpty &#123; println("Nothing to see here")&#125;// prints "Nothing to see here" 字符串可变性1234567var variableString = "Horse"variableString += " and carriage"// variableString is now "Horse and carriage"let constantString = "Highlander"constantString += " and another Highlander"// this reports a compile-time error - a constant string cannot be modified 使用字符1234let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]let catString = String(catCharacters)println(catString)// prints "Cat!🐱" 连接字符串和字符1234567891011let string1 = "hello"let string2 = " there"var welcome = string1 + string2// welcome now equals "hello there"var instruction = "look over"instruction += string2// instruction now equals "look over there"let exclamationMark: Character = "!"welcome.append(exclamationMark)// welcome now equals "hello there!" 字符串插值123let multiplier = 3let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"// message is "3 times 2.5 is 7.5" 字面量中的特殊字符（\0, \\, \t, \n, \r, \“, \’）12345let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"// "Imagination is more important than knowledge" - Einsteinlet dollarSign = "\u&#123;24&#125;" // $, Unicode scalar U+0024let blackHeart = "\u&#123;2665&#125;" // ♥, Unicode scalar U+2665let sparklingHeart = "\u&#123;1F496&#125;" // 💖, Unicode scalar U+1F496 计算字符数量123let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"println("unusualMenagerie has \(count(unusualMenagerie)) characters")// prints "unusualMenagerie has 40 characters" 字符串索引1234567891011121314let greeting = "Guten Tag"// prints "greeting: String = "Guten Tag""println(greeting.startIndex)// 0println(greeting.endIndex)// 9greeting[greeting.startIndex.successor()]// ugreeting[greeting.endIndex.predecessor()]// glet index = advance(greeting.startIndex, 7)greeting[index]// agreeting.endIndex.successor() // fatal error: can not increment endIndex 字符串插入和删除在某个位置插入字符： 1234var welcome = "hello"welcome.insert("!", atIndex: welcome.endIndex)println(welcome)// prints "hello!" 在某个位置插入字符串： 123welcome.splice(" there", atIndex: welcome.endIndex.predecessor())println(welcome)// prints "hello there!" 删除某个位置的字符： 1234welcome.removeAtIndex(welcome.endIndex.predecessor())// !println(welcome)// prints "hello there" 删除某个范围的字符串： 1234let range = advance(welcome.endIndex, -6)..&lt;welcome.endIndexwelcome.removeRange(range)println(welcome)// prints "hello" 字符串和字符比较123456let quotation = "We're a lot alike, you and I."let sameQuotation = "We're a lot alike, you and I."if quotation == sameQuotation &#123; println("These two strings are considered equal")&#125;// prints "These two strings are considered equal" 字符串前缀/后缀相等前缀相等： 12345678910111213141516171819202122let romeoAndJuliet = [ "Act 1 Scene 1: Verona, A public place", "Act 1 Scene 2: Capulet's mansion", "Act 1 Scene 3: A room in Capulet's mansion", "Act 1 Scene 4: A street outside Capulet's mansion", "Act 1 Scene 5: The Great Hall in Capulet's mansion", "Act 2 Scene 1: Outside Capulet's mansion", "Act 2 Scene 2: Capulet's orchard", "Act 2 Scene 3: Outside Friar Lawrence's cell", "Act 2 Scene 4: A street in Verona", "Act 2 Scene 5: Capulet's mansion", "Act 2 Scene 6: Friar Lawrence's cell"]var act1SceneCount = 0for scene in romeoAndJuliet &#123; if scene.hasPrefix("Act 1 ") &#123; ++act1SceneCount &#125;&#125;println("There are \(act1SceneCount) scenes in Act 1")// prints "There are 5 scenes in Act 1" 后缀相等： 1234567891011var mansionCount = 0var cellCount = 0for scene in romeoAndJuliet &#123; if scene.hasSuffix("Capulet's mansion") &#123; ++mansionCount &#125; else if scene.hasSuffix("Friar Lawrence's cell") &#123; ++cellCount &#125;&#125;println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")// prints "6 mansion scenes; 2 cell scenes" UTF-812345for codeUnit in dogString.utf8 &#123; print("\(codeUnit) ")&#125;print("\n")// 68 111 103 226 128 188 240 159 144 182 UTF-1612345for codeUnit in dogString.utf16 &#123; print("\(codeUnit) ")&#125;print("\n")// 68 111 103 8252 55357 56374 Unicode标量12345for scalar in dogString.unicodeScalars &#123; print("\(scalar.value) ")&#125;print("\n")// 68 111 103 8252 128054]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之基本运算符学习笔记]]></title>
      <url>%2F2015%2F04%2F19%2Fthe-swift-programming-language-02-basic-operators%2F</url>
      <content type="text"><![CDATA[赋值运算符1234let b = 10var a = 5a = b// a is now equal to 10 算术运算符123451 + 2 // equals 35 - 3 // equals 22 * 3 // equals 610.0 / 2.5 // equals 4.0"hello, " + "world" // equals "hello, world" 求余运算符129 % 4 // equals 1-9 % 4 // equals -1 浮点数求余运算符18 % 2.5 // equals 0.5 自增和自减运算符12345var a = 0let b = ++a// a and b are now both equal to 1let c = a++// a is now equal to 2, but c has been set to the pre-increment value of 1 单目运算符单目负号运算符： 123let three = 3let minusThree = -three // minusThree equals -3let plusThree = -minusThree // plusThree equals 3, or "minus minus three" 单目正号运算符： 12let minusSix = -6let alsoMinusSix = +minusSix // alsoMinusSix equals -6 复合赋值运算符123var a = 1a += 2// a is now equal to 3 比较运算符1234561 == 1 // true, because 1 is equal to 12 != 1 // true, because 2 is not equal to 12 &gt; 1 // true, because 2 is greater than 11 &lt; 2 // true, because 1 is less than 21 &gt;= 1 // true, because 1 is greater than or equal to 12 &lt;= 1 // false, because 2 is not less than or equal to 1 三目条件运算符1234let contentHeight = 40let hasHeader = truelet rowHeight = contentHeight + (hasHeader ? 50 : 20)// rowHeight is equal to 90 nil合并运算符123456789let defaultColorName = "red"var userDefinedColorName: String? // defaults to nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"userDefinedColorName = "green"colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName is not nil, so colorNameToUse is set to "green" 区间运算符闭区间运算符： 12345678for index in 1...5 &#123; println("\(index) times 5 is \(index * 5)")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 半闭区间运算符： 123456789let names = ["Anna", "Alex", "Brian", "Jack"]let count = names.countfor i in 0..&lt;count &#123; println("Person \(i + 1) is called \(names[i])")&#125;// Person 1 is called Anna// Person 2 is called Alex// Person 3 is called Brian// Person 4 is called Jack 逻辑运算符逻辑非运算符： 12345let allowedEntry = falseif !allowedEntry &#123; println("ACCESS DENIED")&#125;// prints "ACCESS DENIED" 逻辑与运算符： 12345678let enteredDoorCode = truelet passedRetinaScan = falseif enteredDoorCode &amp;&amp; passedRetinaScan &#123; println("Welcome!")&#125; else &#123; println("ACCESS DENIED")&#125;// prints "ACCESS DENIED" 逻辑或运算符： 12345678let hasDoorKey = falselet knowsOverridePassword = trueif hasDoorKey || knowsOverridePassword &#123; println("Welcome!")&#125; else &#123; println("ACCESS DENIED")&#125;// prints "Welcome!" 组合逻辑运算符： 123456if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123; println("Welcome!")&#125; else &#123; println("ACCESS DENIED")&#125;// prints "Welcome!" 显式圆括号： 123456if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123; println("Welcome!")&#125; else &#123; println("ACCESS DENIED")&#125;// prints "Welcome!"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]010.Regular Expression Matching]]></title>
      <url>%2F2015%2F04%2F19%2Fleetcode-010-regular-expression-matching%2F</url>
      <content type="text"><![CDATA[QuestionImplement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true Solution C 123bool isMatch(char* s, char* p) &#123;&#125; C++ 123456class Solution &#123;public: bool isMatch(string s, string p) &#123; &#125;&#125;; Java 12345public class Solution &#123; public boolean isMatch(String s, String p) &#123; &#125;&#125; JavaScript 12345678/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */var isMatch = function(s, p) &#123;&#125;; Python 12345class Solution: # @param &#123;string&#125; s # @param &#123;string&#125; p # @return &#123;boolean&#125; def isMatch(self, s, p): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 语言之基础学习笔记]]></title>
      <url>%2F2015%2F04%2F18%2Fthe-swift-programming-language-01-the-basics%2F</url>
      <content type="text"><![CDATA[常量和变量用let来声明常量，用var来声明变量： 12let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0 类型标注： 12var welcomeMessage: String = "Hello"var red, green, blue: Double 输出常量和变量： 12var friendlyWelcome = "Hello!"println("The current value of friendlyWelcome is \(friendlyWelcome)") 注释单行注释： 1// this is a comment 多行注释（可以嵌套）： 123/* this is the start of the first multiline comment/* this is the second, nested multiline comment */this is the end of the first multiline comment */ 分号同一行内写多条独立语句： 12let cat = "🐱"; println(cat)// prints "🐱" 整数整数范围： 12let minValue = UInt8.min // minValue is equal to 0, and is of type UInt8let maxValue = UInt8.max // maxValue is equal to 255, and is of type UInt8 浮点数略 类型安全和类型推断整数推断 12let meaningOfLife = 42// meaningOfLife is inferred to be of type Int 浮点数推断： 12let anotherPi = 3 + 0.14159// anotherPi is also inferred to be of type Double 数值字面量整数字面量（十进制数没有前缀，二进制数前缀是0b，八进制数前缀是0o，十六进制数前缀是0x）： 1234let decimalInteger = 17let binaryInteger = 0b10001 // 17 in binary notationlet octalInteger = 0o21 // 17 in octal notationlet hexadecimalInteger = 0x11 // 17 in hexadecimal notation 浮点字面量（十进制数没有前缀，指数通过e或E指定，十六进制通过p或P指定）： 123let decimalDouble = 12.1875let exponentDouble = 1.21875e1let hexadecimalDouble = 0xC.3p0 数值字面量增强可读性写法： 123let paddedDouble = 000123.456let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1 数值类型转换整数转换： 123let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one) 整数与浮点数转换： 1234let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine// pi equals 3.14159, and is inferred to be of type Double 类型别名类型别名就是给现有类型定义另外一个名字： 123typealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound is now 0 布尔值12let orangesAreOrange = truelet turnipsAreDelicious = false 元组元组就是把多个值组合成一个复合值： 12345678let http404Error = (404, "Not Found")// http404Error is of type (Int, String), and equals (404, "Not Found")let (statusCode, statusMessage) = http404Errorprintln("The status code is \(statusCode)")// prints "The status code is 404"println("The status message is \(statusMessage)")// prints "The status message is Not Found 如果只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记： 1234let (justTheStatusCode, _) = http404Errorprintln("The status code is \(justTheStatusCode)")// prints "The status code is 404 还可以通过下标来访问元组中的单个元素，下标从零开始： 1234println("The status code is \(http404Error.0)")// prints "The status code is 404"println("The status message is \(http404Error.1)")// prints "The status message is Not Found 可以在定义元组的时候给单个元素命名： 123456let http200Status = (statusCode: 200, description: "OK")println("The status code is \(http200Status.statusCode)")// prints "The status code is 200"println("The status message is \(http200Status.description)")// prints "The status message is OK 可选可以给可选变量赋值为nil来表示它没有值： 1234var serverResponseCode: Int? = 404// serverResponseCode contains an actual Int value of 404serverResponseCode = nil// serverResponseCode now contains no value if语句强制解析： 12345678let possibleNumber = "123"let convertedNumber = possibleNumber.toInt()// convertedNumber is inferred to be of type "Int?", or "optional Intif convertedNumber != nil &#123; println("convertedNumber has an integer value of \(convertedNumber!).")&#125;// prints "convertedNumber has an integer value of 123. 可选绑定： 123456if let actualNumber = possibleNumber.toInt() &#123; println("\(possibleNumber) has an integer value of \(actualNumber)")&#125; else &#123; println("\(possibleNumber) could not be converted to an integer")&#125;// prints "123 has an integer value of 123 隐式解析可选类型： 1234567let possibleString: String? = "An optional string."println(possibleString!) // requires an exclamation mark to access its value// prints "An optional string."let assumedString: String! = "An implicitly unwrapped optional string."println(assumedString) // no exclamation mark is needed to access its value// prints "An implicitly unwrapped optional string. 断言使用断言调试： 123let age = -3assert(age &gt;= 0, "A person's age cannot be less than zero")// this causes the assertion to trigger, because age is not &gt;= 0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]009.Palindrome Number]]></title>
      <url>%2F2015%2F04%2F18%2Fleetcode-009-palindrome-number%2F</url>
      <content type="text"><![CDATA[QuestionDetermine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. Solution C 123bool isPalindrome(int x) &#123;&#125; C++ 123456class Solution &#123;public: bool isPalindrome(int x) &#123; &#125;&#125;; Java 12345public class Solution &#123; public boolean isPalindrome(int x) &#123; &#125;&#125; JavaScript 1234567/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123;&#125;; Python 1234class Solution: # @param &#123;integer&#125; x # @return &#123;boolean&#125; def isPalindrome(self, x): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]008.String to Integer (atoi)]]></title>
      <url>%2F2015%2F04%2F17%2Fleetcode-008-string-to-integer-atoi%2F</url>
      <content type="text"><![CDATA[QuestionImplement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Solution C 123int myAtoi(char* str) &#123;&#125; C++ 123456class Solution &#123;public: int myAtoi(string str) &#123; &#125;&#125;; Java 12345public class Solution &#123; public int myAtoi(String str) &#123; &#125;&#125; JavaScript 1234567/** * @param &#123;string&#125; str * @return &#123;number&#125; */var myAtoi = function(str) &#123;&#125;; Python 1234class Solution: # @param &#123;string&#125; str # @return &#123;integer&#125; def myAtoi(self, str): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]007.Reverse Integer]]></title>
      <url>%2F2015%2F04%2F16%2Fleetcode-007-reverse-integer%2F</url>
      <content type="text"><![CDATA[QuestionReverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior. Solution C 123int reverse(int x) &#123;&#125; C++ 123456class Solution &#123;public: int reverse(int x) &#123; &#125;&#125;; Java 12345public class Solution &#123; public int reverse(int x) &#123; &#125;&#125; JavaScript 1234567/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123;&#125;; Python 1234class Solution: # @param &#123;integer&#125; x # @return &#123;integer&#125; def reverse(self, x): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]006.ZigZag Conversion]]></title>
      <url>%2F2015%2F04%2F15%2Fleetcode-006-zigzag-conversion%2F</url>
      <content type="text"><![CDATA[QuestionThe string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. Solution C 123char *convert(char *s, int nRows) &#123;&#125; C++ 123456class Solution &#123;public: string convert(string s, int nRows) &#123; &#125;&#125;; Java 12345public class Solution &#123; public String convert(String s, int nRows) &#123; &#125;&#125; JavaScript 12345678/** * @param &#123;string&#125; s * @param &#123;number&#125; nRows * @returns &#123;string&#125; */var convert = function(s, nRows) &#123;&#125;; Python 123class Solution: # @return a string def convert(self, s, nRows): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]005.Longest Palindromic Substring]]></title>
      <url>%2F2015%2F04%2F14%2Fleetcode-005-longest-palindromic-substring%2F</url>
      <content type="text"><![CDATA[QuestionGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. Solution C 123char* longestPalindrome(char* s) &#123;&#125; C++ 123456class Solution &#123;public: string longestPalindrome(string s) &#123; &#125;&#125;; Java 12345public class Solution &#123; public String longestPalindrome(String s) &#123; &#125;&#125; JavaScript 1234567/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123;&#125;; Python 1234class Solution: # @param &#123;string&#125; s # @return &#123;string&#125; def longestPalindrome(self, s): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]004.Median of Two Sorted Arrays]]></title>
      <url>%2F2015%2F04%2F13%2Fleetcode-004-median-of-two-sorted-arrays%2F</url>
      <content type="text"><![CDATA[QuestionThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Solution C 123double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;&#125; C++ 123456class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; &#125;&#125;; Java 12345public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; &#125;&#125; JavaScript 12345678/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number&#125; */var findMedianSortedArrays = function(nums1, nums2) &#123;&#125;; Python 12345class Solution: # @param &#123;integer[]&#125; nums1 # @param &#123;integer[]&#125; nums2 # @return &#123;float&#125; def findMedianSortedArrays(self, nums1, nums2): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 分支管理操作]]></title>
      <url>%2F2015%2F04%2F12%2Fgit-branch-management-operations%2F</url>
      <content type="text"><![CDATA[创建仓库创建新文件夹，打开，然后执行： 1$ git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本： 1$ git clone https://github.com/xxx/xxx.git 开发分支Git创建develop分支的命令： 1$ git checkout -b develop master 添加和提交你可以提出更改，使用如下命令： 123$ git add *$ git commit -m "代码提交信息"$ git push origin develop 推送改动将develop分支发布到master分支的命令： 12345$ git checkout master$ git merge --no-ff develop$ git push origin master$ git tag -a v1.0 -m 'xxx version 1.0'$ git push origin v1.0 临时性分支创建一个功能分支： 1$ git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支： 12$ git checkout develop$ git merge --no-ff feature-x 删除feature分支： 1$ git branch -d feature-x 预发布分支创建一个release分支： 1$ git checkout -b release-1.2 develop 确认没有问题后，合并到master分支： 123$ git checkout master$ git merge --no-ff release-1.2$ git tag -a 1.2 再合并到develop分支： 12$ git checkout develop$ git merge --no-ff release-1.2 删除release分支： 1$ git branch -d release-1.2 修补bug分支创建一个修补bug分支： 1$ git checkout -b fixbug-0.1 master 修补结束后，合并到master分支： 123$ git checkout master$ git merge --no-ff fixbug-0.1$ git tag -a 0.1.1 再合并到develop分支： 12$ git checkout develop$ git merge --no-ff fixbug-0.1 删除fixbug分支： 1$ git branch -d fixbug-0.1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]003.Longest Substring Without Repeating Characters]]></title>
      <url>%2F2015%2F04%2F12%2Fleetcode-003-longest-substring-without-repeating-characters%2F</url>
      <content type="text"><![CDATA[QuestionGiven a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1. Solution C 123int lengthOfLongestSubstring(char* s) &#123;&#125; C++ 123456class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; &#125;&#125;; Java 12345public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; &#125;&#125; JavaScript 1234567/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123;&#125;; Python 1234class Solution: # @param &#123;string&#125; s # @return &#123;integer&#125; def lengthOfLongestSubstring(self, s): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown Cheatsheet]]></title>
      <url>%2F2015%2F04%2F11%2Fmarkdown-cheatsheet%2F</url>
      <content type="text"><![CDATA[文章来源于http://assemble.io/docs/Cheatsheet-Markdown.html，版权归属于原作者。 TypographyHeadingsHeadings from h1 through h6 are constructed with a # for each level: 123456# h1 Heading## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading Renders to: h1 Headingh2 Headingh3 Headingh4 Headingh5 Headingh6 HeadingHTML: 123456&lt;h1&gt;h1 Heading&lt;/h1&gt;&lt;h2&gt;h2 Heading&lt;/h2&gt;&lt;h3&gt;h3 Heading&lt;/h3&gt;&lt;h4&gt;h4 Heading&lt;/h4&gt;&lt;h5&gt;h5 Heading&lt;/h5&gt;&lt;h6&gt;h6 Heading&lt;/h6&gt; Horizontal RulesThe HTML &lt;hr&gt; element is for creating a “thematic break” between paragraph-level elements. In markdown, you can create a &lt;hr&gt; with any of the following: ___: three consecutive underscores ---: three consecutive dashes ***: three consecutive asterisks renders to: Body CopyBody copy written as normal, plain text will be wrapped with &lt;p&gt;&lt;/p&gt; tags in the rendered HTML. So this body copy: 1Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. renders to this HTML: 1&lt;p&gt;Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.&lt;/p&gt; EmphasisBoldFor emphasizing a snippet of text with a heavier font-weight. The following snippet of text is rendered as bold text. 1**rendered as bold text** renders to: rendered as bold text and this HTML 1&lt;strong&gt;rendered as bold text&lt;/strong&gt; ItalicsFor emphasizing a snippet of text with italics. The following snippet of text is rendered as italicized text. 1_rendered as italicized text_ renders to: rendered as italicized text and this HTML: 1&lt;em&gt;rendered as italicized text&lt;/em&gt; strikethroughIn GFM you can do strickthroughs. 1~~Strike through this text.~~ Which renders to: Strike through this text. BlockquotesFor quoting blocks of content from another source within your document. Add &gt; before any text you want to quote. 1Add `&gt;` before any text you want to quote. Renders to: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante. and this HTML: 123&lt;blockquote&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt;&lt;/blockquote&gt; Blockquotes can also be nested: 123456&gt; Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue.Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi.&gt;&gt; Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctorodio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam.&gt;&gt;&gt; Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue.Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Renders to: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue.Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctorodio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue.Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. ListsUnorderedA list of items in which the order of the items does not explicitly matter. You may use any of the following symbols to denote bullets for each list item: 123* valid bullet- valid bullet+ valid bullet For example 123456789101112+ Lorem ipsum dolor sit amet+ Consectetur adipiscing elit+ Integer molestie lorem at massa+ Facilisis in pretium nisl aliquet+ Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at+ Faucibus porta lacus fringilla vel+ Aenean sit amet erat nunc+ Eget porttitor lorem Renders to: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem And this HTML 1234567891011121314151617&lt;ul&gt; &lt;li&gt;Lorem ipsum dolor sit amet&lt;/li&gt; &lt;li&gt;Consectetur adipiscing elit&lt;/li&gt; &lt;li&gt;Integer molestie lorem at massa&lt;/li&gt; &lt;li&gt;Facilisis in pretium nisl aliquet&lt;/li&gt; &lt;li&gt;Nulla volutpat aliquam velit &lt;ul&gt; &lt;li&gt;Phasellus iaculis neque&lt;/li&gt; &lt;li&gt;Purus sodales ultricies&lt;/li&gt; &lt;li&gt;Vestibulum laoreet porttitor sem&lt;/li&gt; &lt;li&gt;Ac tristique libero volutpat at&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Faucibus porta lacus fringilla vel&lt;/li&gt; &lt;li&gt;Aenean sit amet erat nunc&lt;/li&gt; &lt;li&gt;Eget porttitor lorem&lt;/li&gt;&lt;/ul&gt; OrderedA list of items in which the order of items does explicitly matter. 123456781. Lorem ipsum dolor sit amet2. Consectetur adipiscing elit3. Integer molestie lorem at massa4. Facilisis in pretium nisl aliquet5. Nulla volutpat aliquam velit6. Faucibus porta lacus fringilla vel7. Aenean sit amet erat nunc8. Eget porttitor lorem Renders to: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem And this HTML: 12345678910&lt;ol&gt; &lt;li&gt;Lorem ipsum dolor sit amet&lt;/li&gt; &lt;li&gt;Consectetur adipiscing elit&lt;/li&gt; &lt;li&gt;Integer molestie lorem at massa&lt;/li&gt; &lt;li&gt;Facilisis in pretium nisl aliquet&lt;/li&gt; &lt;li&gt;Nulla volutpat aliquam velit&lt;/li&gt; &lt;li&gt;Faucibus porta lacus fringilla vel&lt;/li&gt; &lt;li&gt;Aenean sit amet erat nunc&lt;/li&gt; &lt;li&gt;Eget porttitor lorem&lt;/li&gt;&lt;/ol&gt; TIP: If you just use 1. for each number, GitHub will automatically number each item. For example: 123456781. Lorem ipsum dolor sit amet1. Consectetur adipiscing elit1. Integer molestie lorem at massa1. Facilisis in pretium nisl aliquet1. Nulla volutpat aliquam velit1. Faucibus porta lacus fringilla vel1. Aenean sit amet erat nunc1. Eget porttitor lorem Renders to: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem CodeInline codeWrap inline snippets of code with ` . For example, &lt;section&gt;&lt;/section&gt; should be wrapped as “inline”. 1For example, `&lt;section&gt;&lt;/section&gt;` should be wrapped as "inline". Indented codeOr indent several lines of code by at least four spaces, as in: 1234// Some commentsline 1 of codeline 2 of codeline 3 of code // Some comments line 1 of code line 2 of code line 3 of code Block code “fences”Use “fences” ``` ```` to block in multiple lines of code.1234&lt;pre&gt;``` htmlSample text here... 1Sample text here... HTML: 123&lt;pre&gt; &lt;p&gt;Sample text here...&lt;/p&gt;&lt;/pre&gt; Syntax highlightingGFM, or “GitHub Flavored Markdown” also supports syntax highlighting. To activate it, simply add the file extension of the language you want to use directly after the first code “fence”, ` `, and syntax highlighting will automatically be applied in the rendered HTML. For example, to apply syntax highlighting to JavaScript code:123456789101112131415161718192021&lt;pre&gt;``` javascriptgrunt.initConfig(&#123; assemble: &#123; options: &#123; assets: 'docs/assets', data: 'src/data/*.&#123;json,yml&#125;', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.&#123;hbs,md&#125;'] &#125;, pages: &#123; options: &#123; layout: 'default.hbs' &#125;, files: &#123; './': ['src/templates/pages/index.hbs'] &#125; &#125; &#125;&#125;; Renders to: 123456789101112131415161718grunt.initConfig(&#123; assemble: &#123; options: &#123; assets: 'docs/assets', data: 'src/data/*.&#123;json,yml&#125;', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.&#123;hbs,md&#125;'] &#125;, pages: &#123; options: &#123; layout: 'default.hbs' &#125;, files: &#123; './': ['src/templates/pages/index.hbs'] &#125; &#125; &#125;&#125;; And this complicated HTML: 12345678910111213141516171819&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;grunt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;initConfig&lt;/span&gt;&lt;span class="p"&gt;(&#123;&lt;/span&gt; &lt;span class="nx"&gt;assemble&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;&#123;&lt;/span&gt; &lt;span class="nx"&gt;options&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;&#123;&lt;/span&gt; &lt;span class="nx"&gt;assets&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'docs/assets'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'src/data/*.&#123;json,yml&#125;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;helpers&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'src/custom-helpers.js'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;partials&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'src/partials/**/*.&#123;hbs,md&#125;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;&#125;,&lt;/span&gt; &lt;span class="nx"&gt;pages&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;&#123;&lt;/span&gt; &lt;span class="nx"&gt;options&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;&#123;&lt;/span&gt; &lt;span class="nx"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'default.hbs'&lt;/span&gt; &lt;span class="p"&gt;&#125;,&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;&#123;&lt;/span&gt; &lt;span class="s1"&gt;'./'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'src/templates/pages/index.hbs'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;&#125;&lt;/span&gt; &lt;span class="p"&gt;&#125;&lt;/span&gt; &lt;span class="p"&gt;&#125;&lt;/span&gt;&lt;span class="p"&gt;&#125;;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt; TablesTables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned. 12345| Option | Description || ------ | ----------- || data | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext | extension to be used for dest files. | Renders to: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. And this HTML: 123456789101112131415161718&lt;table&gt; &lt;tr&gt; &lt;th&gt;Option&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;data&lt;/td&gt; &lt;td&gt;path to data files to supply the data that will be passed into templates.&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;engine&lt;/td&gt; &lt;td&gt;engine to be used for processing templates. Handlebars is the default.&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;ext&lt;/td&gt; &lt;td&gt;extension to be used for dest files.&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; Right aligned textAdding a colon on the right side of the dashes below any heading will right align text for that column. 12345| Option | Description || ------:| -----------:|| data | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext | extension to be used for dest files. | Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. LinksBasic link1[Assemble](http://assemble.io) Renders to (hover over the link, there is no tooltip): Assemble HTML: 1&lt;a href="http://assemble.io"&gt;Assemble&lt;/a&gt; Add a title1[Upstage](https://github.com/upstage/ "Visit Upstage!") Renders to (hover over the link, there should be a tooltip): Upstage HTML: 1&lt;a href="https://github.com/upstage/" title="Visit Upstage!"&gt;Upstage&lt;/a&gt; Named AnchorsNamed anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters: 1234# Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) will jump to these sections: 12345678## Chapter 1 &lt;a id="chapter-1"&gt;&lt;/a&gt;Content for chapter one.## Chapter 2 &lt;a id="chapter-2"&gt;&lt;/a&gt;Content for chapter one.## Chapter 3 &lt;a id="chapter-3"&gt;&lt;/a&gt;Content for chapter one. NOTE that specific placement of the anchor tag seems to be arbitrary. They are placed inline here since it seems to be unobtrusive, and it works. ImagesImages have a similar syntax to links but include a preceding exclamation point. 1![Minion](http://octodex.github.com/images/minion.png) or1![Alt text](http://octodex.github.com/images/stormtroopocat.jpg "The Stormtroopocat") Like links, Images also have a footnote style syntax 1![Alt text][id] With a reference later in the document defining the URL location: [id]: http://octodex.github.com/images/dojocat.jpg &quot;The Dojocat&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]002.Add Two Numbers]]></title>
      <url>%2F2015%2F04%2F11%2Fleetcode-002-add-two-numbers%2F</url>
      <content type="text"><![CDATA[QuestionYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Solution C 12345678910/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;&#125; C++ 123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; &#125;&#125;; Java 12345public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; &#125;&#125; JavaScript 12345678/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;&#125;; Python 12345class Solution: # @param &#123;integer[]&#125; nums # @param &#123;integer&#125; target # @return &#123;integer[]&#125; def twoSum(self, nums, target): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[LeetCode]001.Two Sum]]></title>
      <url>%2F2015%2F04%2F10%2Fleetcode-001-two-sum%2F</url>
      <content type="text"><![CDATA[QuestionGiven an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 Solution C 123int *twoSum(int numbers[], int n, int target) &#123;&#125; C++ 123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; &#125;&#125;; Java 12345public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; &#125;&#125; JavaScript 12345678/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; two integers in an array, ie: [index1, index2] */var twoSum = function(numbers, target) &#123;&#125;; Python 123class Solution: # @return a tuple, (index1, index2) def twoSum(self, num, target): Swift 1Hello World]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2015%2F04%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
